<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

<!--@doc-title Simple Menu API -->
<!--
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

Note: raise_lua_event only supports passing strings, numbers, or components.
This api will pass complex tables of args using a blackboard var:
  player.entity.{'$simple_menu_args'}
  
TODO: widget autoupdate support. See widgetPrototypes.frame:update() for
the widget properties that support a lua function callback. Do something
similar to enable update cues.
-->
  
<cues>

  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.simple_menu_api.lua.Interface'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * row
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * menu_properties
      - Table holding the menu creation args of the most recent menu.
    * widget_properties
      - Table of tables of properties provided by the user for widgets, 
        annotated with additional information (eg. row number).
      - Holds shallow copies of the user args tables.
      - Outer table keyed by widget row, inner table by widget column.
      - Outer table may also be keyed by widget id, when the user provides
        an id string; in such cases the widget properties table will be
        recorded twice (by id and row/col).
      - Locally used for the callback cue storage, with echoing behavior
        intended to aid the user in handling callbacks.
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu.
      
    Additionally, complex data will be sent to lua using a blackboard var:
    * player.entity.{'$simple_menu_args'}
      - List of tables (or none), args sent with lua commands.
      - The list is appended to here, copied and deleted in lua.
      - The list is used to account for (common) cases where multiple commands
        are sent in the same frame, since the lua will only process them late
        in the frame, requiring arg buffering.
      - Since lua cannot edit the list directly, and cannot replace it with
        a modified list, it will just delete this var after reading it.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Named_Pipes'" control="'reloaded'" />
        </conditions>
        <actions>
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="100" />
      <set_value name="Globals.$widget_properties" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />
      <set_value name="Globals.$menu_properties" exact="table[]" />
      <!-- Reset the blackboard list, to clear old junk. TODO: delete. -->
      <set_value name="player.entity.{'$simple_menu_args'}" exact="[]" />
    </actions>
  </library>

  <!--
    Library function which will reset before opening a new menu.
    Clears out state from the prior menu.
  -->
  <library name="Reset_Menu">
    <actions>
      <set_value name="Globals.$widget_properties" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$menu_properties" exact="table[]" />
      <set_value name="player.entity.{'$simple_menu_args'}" exact="[]" />
    </actions>
  </library>

  
  <!--@doc-cue
    Dummy cue used for signalling that the game or ui was reloaded.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


  <!--@doc-cue
    Dummy cue used for signalling when the menu system is requesting
    an update, approximately every 0.1 seconds.  This will continue to
    trigger during game pauses, unlike MD delays.
    Users may listen to this to trigger widget property updates.
    
    Pending development.
  -->
  <cue name="Clock" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


  <!-- 
    Helper lib function to do some processing on user provided call args.
    The original event.param should be placed in $args, and the associated
    command name placed in $command.
    
    If the user event/param was none, this makes a default table first.
    -->
  <library name="Process_Args">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
      <!-- Add the command to it. -->
      <set_value name="$args.{'$command'}" exact="$command"/>
    </actions>
  </library>
  
  
  <!-- 
    Depricated; now pass args using player blackboard.
    Serializes an args table into a string, for passing to lua.
    The table should be flat, with no subtables or sublists.
    
    Input table should be in $args.
    Results strings is in $args_str.
    Overwrites $i, $key, $value.
    
    Note on raise_lua_event param:
    - Can pass:
      string
      integer (becomes number)
      float (becomes number)
    - Can't pass:
      table (becomes nil)
      list (becomes nil)
    -->
  <library name="Serialize_Args">
    <actions>
      <set_value name="$args_str" exact="''" />
              
      <!-- Loop over the param table's keys. -->
      <do_all exact="$args.keys.list.count" counter="$i">
        <!-- Isolate key and value. -->
        <set_value name="$key" exact="$args.keys.list.{$i}" />
        <set_value name="$value" exact="$args.{$key}" />
        
        <!-- Skip data like tables/lists that the user is echoing. -->
        <do_if value="$key != '$echo'">        
          <!-- 
            Add to the running args string. Add prefix semicolon after first arg.
            This makes separting in lua a bit easier.
            -->
          <do_if value="$i != 1">
            <set_value name="$args_str" exact="$args_str + ';'" />
          </do_if>
          <!-- Add to the running args string. -->
          <set_value name="$args_str" exact="$args_str + $key + ',' + $value" />
        </do_if>
      </do_all>
    </actions>
  </library>
  
  <!-- 
    Adds a table of args to the player.entity '$simple_menu_args' list,
    creating it if it doesn't exist, so that lua can access it.
    
    Input table should be in $args.    
    -->
  <library name="Blackboard_Args">
    <actions>
      <!-- Create the blackboard list if it doesn't exist. -->
      <do_if value="not player.entity.{'$simple_menu_args'}?">
        <set_value name="player.entity.{'$simple_menu_args'}" exact="[]" />
      </do_if>
      <append_to_list name="player.entity.{'$simple_menu_args'}" exact="$args"/>
    </actions>
  </library>

  
  <!--@doc-cue
    Register an options menu, which will be accessible as a submenu of
    the normal game options.
    
    Param:
      Table with the following items:
      * $id
        - String, unique identifier for this menu.
        - Needs to differ from egosoft menu names, as well as any other
          mod registered menus.
      * $title
        - Text to display in the table header.
      * $columns
        - Integer, total number of columns in the menu table.
      * $cue
        - Cue to be called when the submenu needs to be built.
        - This cue should use addRow and makeX functions to build the menu.
        - Do not call Create_Menu from this cue.
      * $private
        - Int 0 or 1, optional, controls if the menu will be listed automatically
          in the general list of Extension Options menus.
        - Defaults to 0, non-private.
        - Set to private for submenus you will manually link to using
          Add_Submenu_Link.
                
    Call this each time the Reloaded cue is signalled. Example:
    ```xml
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $cue     = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    ```
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Make a safety copy of the args. -->
      <set_value name="$args" exact="event.param.clone" />
      
      <!-- Record the args using the menu id, $ prefixed. -->
      <set_value  name="Globals.$options_submenu_specs.{'$'+event.param.{'$id'}}" exact="$args" />
            
      <debug_text text="'Sending Register_Options_Menu with args: %s'.[$args]" 
                chance="Globals.$DebugChance" filter="general"/>
                
      <include_actions ref="Blackboard_Args"/>
      <raise_lua_event name="'Simple_Menu.Register_Options_Menu'"/>
    </actions>
  </cue>


  <!--TODO: change onClose_cue to onClose-->
  <!--@doc-cue
    Create a fresh standalone menu.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Param:
      Table with the following items:
      * columns
        - Integer, total number of columns in the menu table.
      * title
        - Text to display in the table header.
      * width
        - Int, optional, menu width. Defaults to a predefined width.
      * height
        - Int, optional, menu height. Default expands to fit contents.
      * offsetX
      * offsetY
        - Ints, optional, amount of space between menu and screen edge.
        - Positive values taken from top/left of screen, negative values
          from bottom/right of screen.
        - Defaults will center the menu.
      * onClose_cue
        - Cue, optional, signalled when the menu is closed.
        - The event.param will be "back" or "close" depending on if the
          menu back button was pressed.
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Reset old state. -->
      <include_actions ref="Reset_Menu"/>
      
      <!-- Save a copy of the args. -->
      <set_value name="Globals.$menu_properties" exact="event.param.clone"/>      
      
      <set_value name="$command" exact="'Create_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Close_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Display the menu.
    Mainly for use with options menus, which requires this to know when
    all build commands are complete.
    -->
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Display_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu.
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * menu_id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Add_Submenu_Link'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Add a row to the current menu.
    Following Make_ commands add to the most recently added row.
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Update the row count, and expand the callback table. -->
      <set_value name="Globals.$row" exact="Globals.$row + 1" />
      <set_value name="Globals.$widget_properties.{Globals.$row}" exact="table[]" />
      
      <set_value name="$command" exact="'Add_Row'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  
  <!-- Lib helper for fill in default widget args.
       The args table should be in $args.
  -->
  <library name="Fill_Widget_Default_Args">
    <actions>
      <!-- Currently just set col to 1 by default. -->
      <do_if value="not $args.{'$col'}?">
        <set_value name="$args.{'$col'}" exact="1" />
      </do_if>
    </actions>
  </library>
  
  <!--TODO: document Helper constants.-->
  <!--@doc-section
    ### Widget arguments and properties overview
    
    The following "Make_" cues create widgets. Many of them share some common
    arguments or arg data types, described here.
    
    After creation, widgets may be partially updated at any time. This is
    detailed in the Update_Widget cue.
    
    In the egosoft backend, there is a "Helper" module which defines many
    constants used in the standard menus such as colors, fonts, etc.
    Arguments may optionally be given as a string matching a Helper const,
    eg. "Helper.color.brightyellow".
    
    
    API args (all widgets)
    * col
      - Integer, column to place the widget in.
      - Uses 1-based indexing.
      - Required for now.
    * id = none
      - String, unique identifier for the widget.
      - Optional, but needed for Update_Widget calls.
    * echo = none
      - May be any data type.
      - This is returned in the table sent to signalled callback cues,
        for user convenience.
    
    Widget properties (all widgets)
    * scaling = true
      - Bool, coordinates and dimensions will be scaled by the ui scaling factor.
    * width, height = 0
      - Ints, widget dimension overrides.
    * x, y = 0
      - Ints, placement offsets.
    * mouseOverText = ""
      - String, text to display on mouseover.
        
    Cell properties (all widgets)
    * cellBGColor = Helper.defaultSimpleBackgroundColor
      - Color, cell background color.
    * uiTriggerID = none
      - String, if present then this is the control field for ui
        triggered events on widget activations.
      - Ignore for now; api handles callback cues directly.
        
    Events (depends on widget)
    * on<___> (onClick, onTextChanged, etc.)
      - Optional callback cue.
      - When the player interacts with most widgets, ui events will occur.
        On such events, a provided cue will be called with the event results.
      - All event.param tables will include these fields:
        * row, col
          - Longfloat, coordinate of the activated widget.
          - Primarily for use by this backend.
        * id
          - String id given to the widget at creation, or null.
        * event
          - String, name of the event, matching the arg name.
          - Eg. "onClick".
        * echo
          - Same as the "echo" arg provided to widget creation.
      - Extra contents of the event.param are described per widget below.
        
    Misc properties (depends on widget):
    * font
      - String, font to use.
      - Typical options: 
        - "Zekton"
        - "Zekton bold"
        - "Zekton fixed"
        - "Zekton bold fixed"
        - "Zekton outlined"
        - "Zekton bold outlined"
    * fontsize
      - Int, typically in the 9 to 12 range.
    * halign
      - String, text alignment, one of ["left", "center", "right"].
    * minRowHeight
      - Int, minimal row height, including y offset.
        
    Complex properties:
    * Color
      - Table of ["r", "g", "b", "a"] integer values in the 0-255 range.
    * TextProperty
      - Table describing a text field.
      - Note: in some widgets "text" is a string, others "text" is
        a TextProperty table.
      - Fields:
        * text = ""
        * halign = Helper.standardHalignment
        * x = 0
        * y = 0
        * color = Helper.standardColor
        * font = Helper.standardFont
        * fontsize = Helper.standardFontSize
        * scaling = true
    * IconProperty
      - Table describing an icon.
      - Fields:
        * icon = ""
          - Icon ID/name
        * swapicon = ""
        * width = 0
        * height = 0
        * x = 0
        * y = 0
        * color = Helper.standardColor
        * scaling = true
    * HotkeyProperty
      - Table describing an activation hotkey.
      - See libraries/contexts.xml for potential options.
      - Note: hotkeys have not yet worked in testing.
      - Fields:
        * hotkey = ""
          - String, the hotkey action, matching a valid INPUT_STATE.
        * displayIcon = false
          - Bool, if the widget displays the associated icon as a hotkey.
        * x = 0
        * y = 0
          - Offsets of the icon if displayIcon is true.
          
  -->

  <!--@doc-section
    ### Widget Creation Cues
    -->
  
  <!--@doc-cue
    Make a label cell for displaying text.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * titleColor
      - If given, puts the widget in title mode.
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    -->
  <cue name="Make_Label" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Label'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>      
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a box-text cell.  Similar to a label.
    Adds to the most recent row.
    
    Pending development.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * boxColor
      - Updateable
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    -->
  <cue name="Make_BoxText" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_BoxText'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a pressable button cell.
    Adds to the most recent row.
    
    Param: Table with the following items.
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties   
    * onClick
      - Cue to callback when the button is left clicked.
    * onRightClick
      - Cue to callback when the button is right clicked.
    * text
      - TextProperty.
      - Updateable text and color
    * text2
      - TextProperty.
      - Updateable text and color
    * active = true
      - Bool, if the button is active.
      - Updateable
    * bgColor = Helper.defaultButtonBackgroundColor
      - Color of background.
      - Updateable
    * highlightColor = Helper.defaultButtonHighlightColor
      - Color when highlighted.
      - Updateable
    * icon
      - IconProperty
    * icon2
      - IconProperty
    * hotkey
      - HotkeyProperty
      
      
    onClick event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Button'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a edit box cell, for text entry.
    Adds to the most recent row.
    Every letter change will trigger a callback.
    
    Warning: due to a (likely) typo bug, x4 is limited to 5 text edit boxes.
    If many edit fields are needed, consider using sliders for numeric values
    (limit 50), where users can click the slider displayed value to use it
    like an editbox.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onTextChanged
      - Cue to call when the player changes the box text. 
      - Occurs on every letter change.
    * onEditBoxDeactivated
      - Cue to call when the player deselects the box.
      - Deselection may occur when selecting another element, pressing enter,
        or pressing escape.
      - Does not trigger if the menu is closed.
    * bgColor = Helper.defaultEditBoxBackgroundColor
      - Color of background.
    * closeMenuOnBack = false
      - Bool, if the menu is closed when the 'back' button is pressed while
        the editbox is active.
      - Description unclear.
    * defaultText
      - String, the default text to display when nothing present.
      - Updateable
    * textHidden = false
      - Bool, if the text is invisible.
    * encrypted = false
      - Bool, if the input has an encrypted style of display.
    * text
      - TextProperty
    * hotkey
      - HotkeyProperty
      
      
    onTextChanged event returns:
    * row, col, echo, event, id
    * text
      - String, the new text in the box.
        
    onEditBoxDeactivated event returns:
    * row, col, echo, event, id
    * text
      - String, the current text in the box.
    * textchanged
      - Bool, if the text was changed since being activated.
    * wasconfirmed
      - Bool, false if the player pressed "escape", else true.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_EditBox'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a horizontal slider cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onSliderCellChanged
      - Cue to call when the slider value is changed.
      - When the player drags the slider around, this will be called
        repeatedly at intermediate points.
      - When the player types into the editbox, this will trigger on
        every typed character.
    * onSliderCellActivated
      - Cue to call when the player activates the slider.
    * onSliderCellConfirm
      - Cue to call when the player deactivates the slider.
      - Triggers less often than onSliderCellChanged.
      - Recommend using this in general.
    * bgColor = Helper.defaultSliderCellBackgroundColor
      - Color of background.
    * valueColor = Helper.defaultSliderCellValueColor
      - Color of value.
    * posValueColor = Helper.defaultSliderCellPositiveValueColor
      - Color, positive value if fromCenter is true
    * negValueColor = Helper.defaultSliderCellNegativeValueColor
      - Color, negative value if fromCenter is true
    * min = 0
      - Min value the bar is sized for
    * max = 0
      - Max value the bar is sized for
      - Updateable
    * minSelect = none
      - Min value the player may select.
      - Defaults to min
      - Do not use maxSelect if exceedMaxValue is true
    * maxSelect
      - Max value the player may select.
      - Defaults to max
      - Updateable
    * start = 0
      - Initial value
    * step = 1
      - Step size between slider points
    * suffix = ""
      - String, suffix on the displayed current value.
    * exceedMaxValue = false
      - Bool, if the player can go over the max value.
      - Requires min >= 0.
    * hideMaxValue = false
      - Bool, hides the max value.
    * rightToLeft = false
      - Bool, enables a right/left mirrored bar.
    * fromCenter = false
      - Bool, bar extends from a zero point in the center.
    * readOnly = false
      - Bool, disallows player changes.
    * useInfiniteValue = false
      - Bool, sets slider to show infinity when infiniteValue is reached.
    * infiniteValue = 0
      - Value at which to show infinity when useInfiniteValue is true.
    * useTimeFormat = false
      - Bool, sets the slider to use a time format.
    
    
    onSliderCellChanged event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
      
    onSliderCellActivated event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    * posx, posy
      - Coordinates of the widget (likely not useful).
      
    onSliderCellConfirm event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
    * valuechanged
      - Bool, true if the value changed since being activated.
      - If the player escapes out of the editbox, this will be false and
        the value will be the pre-edit value.
      
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Slider'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a dropdown selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * options
      - List of tables describing each option.
      - Each subtable has these fields:
        * text = ""
          - String, option text.
        * icon = ""
          - String, icon name.
        * id
          - Optional string or number, identifier of the option.
          - Returned to callbacks to indicate option selected.
          - Defaults to the option's list index (1-based).
        * displayremoveoption = false
          - Bool, if true the option will show an 'x' that the player can
            click to remove it from the dropdown list.
    * onDropDownActivated
      - Cue to call when the player activates the dropdown.
    * onDropDownConfirmed
      - Cue to call when the player selects an option.
    * onDropDownRemoved
      - Cue to call when the player removes an option.
    * startOption = ""
      - String or number, id of the initially selected option.
      - Updateable
    * active = true
     - Bool, if the widget is active.
    * bgColor = Helper.defaultButtonBackgroundColor
     - Color of background.
    * highlightColor = Helper.defaultButtonHighlightColor
     - Color when highlighted.
    * optionColor = Helper.color.black
      - Color of the options.
    * optionWidth, optionHeight = 0
      - Dimensions of the options.
    * allowMouseOverInteraction = false
      - Bool, ?
    * textOverride = ""
      - String, ?
    * text2Override = ""
      - String, ?
    * text
     - TextProperty
    * text2
     - TextProperty
    * icon
     - IconProperty
    * hotkey
     - HotkeyProperty
      
      
    onDropDownActivated event returns:
    * row, col, echo, event, id
        
    onDropDownConfirmed event returns:
    * row, col, echo, event, id
    * id
      - String or number, id of the selected option.
      
    onDropDownRemoved event returns:
    * row, col, echo, event, id
    * id
      - String or number, id of the removed option.
      
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Dropdown'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make an icon cell.
    Adds to the most recent row.
    
    Pending development.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * icon = ""
      - String, icon id
      - Updateable
    * color = Helper.standardColor
      - Color
      - Updateable
    * text
      - TextProperty
      - Updateable text
    * text2
      - TextProperty
      - Updateable text
    -->
  <cue name="Make_Icon" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Icon'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a check-box.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onClick
      - Cue to callback when the checkbox is clicked.
    * checked = false
      - Bool or int, if checked initially.
      - Updateable
    * bgColor = Helper.defaultCheckBoxBackgroundColor
     - Color of background.
    * active = true
     - Bool, if the widget is active.
     
    onClick event returns:
    * row, col, echo, event, id
    * checked
      - Int, 0 or 1, checkbox status after click.
      
    -->
  <cue name="Make_CheckBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_CheckBox'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--@doc-cue
    Make a status bar.
    Adds to the most recent row.
    
    Pending development.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * current = 0
      - Int
      - Updateable
    * start = 0
      - Int
      - Updateable
    * max = 0
      - Int
      - Updateable
    * valueColor = Helper.defaultStatusBarValueColor
      - Color
    * posChangeColor = Helper.defaultStatusBarPosChangeColor
      - Color
    * negChangeColor = Helper.defaultStatusBarNegChangeColor
      - Color
    * markerColor = Helper.defaultStatusBarMarkerColor
      - Color
    -->
  <cue name="Make_StatusBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_StatusBar'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <include_actions ref="Fill_Widget_Default_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>




  <!--@doc-cue
    General cue for packaging up a request and sending it to lua.
    This may be used instead of the Make_ command, by filling in a matching
    command name in the param table.
    
    Param: Table with the following items
    * command
      - String, command to send to lua.
    * ...
      - Any args requied for the command.
  -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- If the param is null, something went wrong in the call. TODO -->
      
      <!-- Use a shallow copy for this, to avoid errors if the user reuses tables. -->
      <set_value name="$args" exact="event.param.clone" />
            
      <!-- Record the Make_ args, which may have callback cues needed later. 
            TODO: a good way to detect Make_ commands.
            For now, just test for the col arg, which nothing else uses. -->
      <do_if value="$args.{'$col'}?">
        
        <!-- Store the row in the args, for possible later lookup. -->
        <set_value name="$args.{'$row'}" exact="Globals.$row" />
        
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <set_value name="Globals.$widget_properties.{Globals.$row}.{$args.{'$col'}}" exact="$args" />
        <debug_text text="'Recorded args for row,col: (%s,%s)'.[Globals.$row, $args.{'$col'}]"
                  chance="Globals.$DebugChance" filter="general"/>
        
        <!-- Also record by user id, if available. -->
        <do_if value="$args.{'$id'}?">
          <set_value name="Globals.$widget_properties.{'$'+ $args.{'$id'}}" exact="$args" />
        </do_if>
        
      </do_if>
      
      <!-- Add to the player blackboard. -->
      <include_actions ref="Blackboard_Args"/>

      <debug_text text="'Sending Process_Command with args: %s'.[$args]" 
                chance="Globals.$DebugChance" filter="general"/>
                
      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'"/>
    </actions>
  </cue>


  <!--@doc-cue
    Update a widget's state after creation.
    
    Param: Table with the following items
    * id
      - String, original id assigned to the widget at creation.
    * ...
      - Any args to be updated, matching the original widget creation args
        layout.
      - Which widget properties can be updated depends on the specific widget.
  -->
  <cue name="Update_Widget" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param" />
      
      <!-- Look up the id in recorded widget properties. -->
      <!-- Skip if there is an id problem. -->
      <do_if value="$args.{'$id'}? and Globals.$widget_properties.{'$'+ $args.{'$id'}}?">
        <set_value name="$args_table" exact="Globals.$widget_properties.{'$'+ $args.{'$id'}}"/>
        
        <!-- Fill in the row/col for the lua to find this widget. -->
        <set_value name="$args.{'$row'}" exact="$args_table.{'$row'}" />
        <set_value name="$args.{'$col'}" exact="$args_table.{'$col'}" />
        
        <!-- Set command string. -->
        <set_value name="$args.{'$command'}" exact="'Update_Widget'" />
        
        <!-- Send it off. -->
        <include_actions ref="Blackboard_Args"/>
        <debug_text text="'Sending Process_Command with args: %s'.[$args]"
                  chance="Globals.$DebugChance" filter="general"/>
        <raise_lua_event name="'Simple_Menu.Process_Command'"/>
      </do_if>
      <do_else>
        <debug_text text="'Found no widget with id: %s'.[$args.{'$id'}]"
                  chance="Globals.$DebugChance" filter="general"/>
      </do_else>

    </actions>
  </cue>
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets. Handle callbacks to user cues.
    
    The callback will echo the original widget args table, annotated with
    the data returned from lua. User code may use this feature to attach
    data to widgets at creation time, and use that echo'd data in
    callback handling.
        
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. This table will always have
    $row and $col of the widget the player modified, along with any
    per-widget state information.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
                
      <!-- Look up the callback cue for this row/col and event. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$args_table" exact="@Globals.$widget_properties.{$response.{'$row'}}.{$response.{'$col'}}" />
      <set_value name="$cue" exact="@$args_table.{'$' + $response.{'$event'}}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
              
        <!-- Add the $echo to the response, or null. -->
        <set_value name="$response.{'$echo'}" exact="@$args_table.{'$echo'}" />

        <!-- Add the $id to the response, or null. -->
        <set_value name="$response.{'$id'}" exact="@$args_table.{'$id'}" />
        
        <signal_cue_instantly cue="$cue" param="$response"/>
      </do_if>
      
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for row,col: (%s,%s)'.[$response.{'$row'}, $response.{'$col'}]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$options_submenu_specs.{'$'+$id}.{'$cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        
        <!-- Reset old state. -->
        <include_actions ref="Reset_Menu"/>
        
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue"/>
        
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  <!--
    Listen for the lua signal of a closed standalone menu.
    event.param3 is a string, either "back" or "close", depending on
    if a back button was used or not.
  -->
  <cue name="Capture_Lua_Menu_Close" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'onCloseElement'" />
    </conditions>
    
    <actions>
      <!-- Look up the callback cue. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$menu_properties.{'$onClose_cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="event.param3" />
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu closing.'" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>


  <!--
    Listen for the lua signal requesting any widget updates.
    This will signal the Update cue, and then will run a subcue that
    resends the widget properties to lua.
    
    Note: this means that user updates will be delayed one cycle.
    TODO: set up a lua 1-frame delayed trigger for updating widgets.
     (Note: md delay won't work while the game is paused.)
  -->
  <cue name="Capture_Lua_Update_Trigger" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Update'" />
    </conditions>

    <actions>
      <!-- Signal the Update cue, and indirectly listening users. -->
      <signal_cue_instantly cue="Update"/>      
    </actions>

    <cues>
      <cue name="Send_Updated_Commands">
        <delay exact="1ms"/>
        <actions>
          
          <!-- Loop over all of the stored widget command args. -->
          <do_all exact="Globals.$widget_properties.list.count" counter="$row_index">
            <set_value name="$row" exact="Globals.$widget_properties.list.{$row_index}"/>
            <do_all exact="$row.list.count" counter="$col_index">
              <set_value name="$widget" exact="$row.list.{$col_index}"/>

              <!-- Skip if this widget is not flagged for updates. -->
              <do_if value="$widget.{'$enable_updates'}">
                <!--Resend the creation command; backend will know to update 
                based on widget already existing.-->
                <signal_cue_instantly cue="Send_Command" param="$widget"/>
              </do_if>
            </do_all>
          </do_all>
          
        </actions>
      </cue>
    </cues>
  </cue>
  
</cues>

</mdscript>