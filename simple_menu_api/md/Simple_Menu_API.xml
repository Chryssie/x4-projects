<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xsi:noNamespaceSchemaLocation="md.xsd">

<!--@doc-title Simple Menu API -->
<!--
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

-->
  
<cues>

  <!-- Register the lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.simple_menu_api.Simple_Menu'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * row
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * menu_properties
      - Table holding the menu creation args of the most recent menu.
    * widget_properties
      - Table of tables of properties provided by the user for widgets, to
        be returned during callbacks.
      - Outer table keyed by widget row, inner table by widget column.
      - Only recorded for widgets with callback cues.
      - Uses a shallow copy of the user args table.
      - Locally used for the callback cue storage, with echoing behavior
        intended to aid the user in handling callbacks.
      - TODO: consider storing a copy of the args table, instead of the
        actual table.
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Named_Pipes'" control="'reloaded'" />
        </conditions>
        <actions>
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="100" />
      <set_value name="Globals.$widget_properties" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />
      <set_value name="Globals.$menu_properties" exact="table[]" />
    </actions>
  </library>

  
  <!--
    Dummy cue used for signalling.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


  <!-- 
    Helper lib function to do some processing on user provided call args.
    The original event.param should be placed in $args, and the associated
    command name placed in $command.
    
    If the user event/param was none, this makes a default table first.
    -->
  <library name="Process_Args">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
      <!-- Add the command to it. -->
      <set_value name="$args.{'$command'}" exact="$command"/>
    </actions>
  </library>
  
  
  <!-- 
    Serializes an args table into a string, for passing to lua.
    The table should be flat, with no subtables or sublists.
    
    Input table should be in $args.
    Results strings is in $args_str.
    Overwrites $i, $key, $value.
    
    Note on raise_lua_event param:
    - Can pass:
      string
      integer (becomes number)
      float (becomes number)
    - Can't pass:
      table (becomes nil)
      list (becomes nil)
    -->
  <library name="Serialize_Args">
    <actions>
      <set_value name="$args_str" exact="''" />
              
      <!-- Loop over the param table's keys. -->
      <do_all exact="$args.keys.list.count" counter="$i">
        <!-- Isolate key and value. -->
        <set_value name="$key" exact="$args.keys.list.{$i}" />
        <set_value name="$value" exact="$args.{$key}" />
        
        <!-- Skip data like tables/lists that the user is echoing. -->
        <do_if value="$key != '$echo'">        
          <!-- 
            Add to the running args string. Add prefix semicolon after first arg.
            This makes separting in lua a bit easier.
            -->
          <do_if value="$i != 1">
            <set_value name="$args_str" exact="$args_str + ';'" />
          </do_if>
          <!-- Add to the running args string. -->
          <set_value name="$args_str" exact="$args_str + $key + ',' + $value" />
        </do_if>
      </do_all>
    </actions>
  </library>
  
  <!--@doc-cue
    Register an options menu, which will be accessible as a submenu of
    the normal game options.
    
    Param:
      Table with the following items:
      * $id
        - String, unique identifier for this menu.
        - Needs to differ from egosoft menu names, as well as any other
          mod registered menus.
      * $title
        - Text to display in the table header.
      * $columns
        - Integer, total number of columns in the menu table.
      * $cue
        - Cue to be called when the submenu needs to be built.
        - This cue should use addRow and makeX functions to build the menu.
        - Do not call Create_Menu from this cue.
      * $private
        - Int 0 or 1, optional, controls if the menu will be listed automatically
          in the general list of Extension Options menus.
        - Defaults to 0, non-private.
        - Set to private for submenus you will manually link to using
          Add_Submenu_Link.
                
    Call this each time the Reloaded cue is signalled. Example:
    ```xml
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $cue     = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    ```
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Select an id for the menu, based on the next spec index. -->
      <!-- <set_value name="event.param.{'$id'}" exact="Globals.$options_submenu_specs.count +1" /> -->
      
      <!-- Record the args using the menu id, $ prefixed. -->
      <set_value  name="Globals.$options_submenu_specs.{'$'+event.param.{'$id'}}" exact="event.param" />
      
      <!-- Convert the table to a string. -->
      <set_value name="$args" exact="event.param" />
      <include_actions ref="Serialize_Args"/>
            
      <debug_text text="'Sending Register_Options_Menu with args: %s'.[$args_str]" 
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Register_Options_Menu'" param="$args_str"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Create a fresh standalone menu.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Param:
      Table with the following items:
      * columns
        - Integer, total number of columns in the menu table.
      * title
        - Text to display in the table header.
      * width
        - Int, optional, menu width. Defaults to a predefined width.
      * height
        - Int, optional, menu height. Default expands to fit contents.
      * offsetX
      * offsetY
        - Ints, optional, amount of space between menu and screen edge.
        - Positive values taken from top/left of screen, negative values
          from bottom/right of screen.
        - Defaults will center the menu.
      * onClose_cue
        - Cue, optional, signalled when the menu is closed.
        - The event.param will be "back" or "close" depending on if the
          menu back button was pressed.
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Reset old state. -->
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$widget_properties" exact="table[]" />
      
      <!-- Save a copy of the args. -->
      <set_value name="Globals.$menu_properties" exact="event.param.clone"/>      
      
      <set_value name="$command" exact="'Create_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Close_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Display the menu.
    Mainly for use with options menus, which requires this to know when
    all build commands are complete.
    -->
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Display_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu.
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * menu_id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Add_Submenu_Link'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Add a row to the current menu.
    Following Make_ commands add to the most recently added row.
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Update the row count, and expand the callback table. -->
      <set_value name="Globals.$row" exact="Globals.$row + 1" />
      <set_value name="Globals.$widget_properties.{Globals.$row}" exact="table[]" />
      
      <set_value name="$command" exact="'Add_Row'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a label cell for displaying text.
    Adds to the most recent row.
    
    Param:
      Table with the following items:
      * col
        - Integer, column to place the widget in.
      * text
        - Text to display, without semicolons.
      * mouseover
        - Optional, extra text to display on mouseover.
    -->
  <cue name="Make_Label" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Label'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a pressable button cell.
    Adds to the most recent row.
    
    Param:
      Table with the following items:
      * col
        - Integer, column to place the widget in.
      * cue
        - Cue to callback on interact event.
      * text
        - Text to display, without semicolons.
      * echo
        - Optional, anything, returned on callback.
      
    onClick event returns a table with:
      * row
        - Longfloat, row of the widget.
      * col
        - Longfloat, col of the widget.
      * echo
        - Present if param had echo.
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Button'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a edit box cell, for text entry.
    Adds to the most recent row.
    Every letter change will trigger a callback.
    
    Warning: due to a (likely) typo bug, x4 is limited to 5 text edit boxes.
    If many edit fields are needed, consider using sliders for numeric values
    (limit 50), where users can click the slider displayed value to use it
    like an editbox.
    
    Param:
      Table with the following items:
      * col
        - Integer, column to place the widget in.
      * cue
        - Cue to callback on interact event.
      * text
        - Optional, initial text to display, without semicolons.
      * echo
        - Optional, anything, returned on callback.
      
    onTextChanged event returns a table with:
      * row
        - Longfloat, row of the widget.
      * col
        - Longfloat, col of the widget.
      * text
        - String, new text in the box.
      * echo
        - Present if param had echo.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_EditBox'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a horizontal slider cell.
    Adds to the most recent row.
    Every slider adjustment (many per sweep) triggers a callback.
    
    Param:
      Table with the following items:
      * col
        - Integer, column to place the widget in.
      * cue
        - Cue to callback on interact event.
      * min
        - Int, min value.
      * minSelect
        - Int, optional, min selectable value if different than min.
      * max
        - Int, max value.
      * maxSelect
        - Int, optional, max selectable value if different than max.
      * start
        - Int, optional, initial value; defaults 0.
      * step
        - Int, optional, step size; defaults 1.
      * suffix
        - String, optional, suffix displayed on the value, eg. " %".
      * echo
        - Optional, anything, returned on callback.
      
    onSliderCellChanged event returns a table with:
      * row
        - Longfloat, row of the widget.
      * col
        - Longfloat, col of the widget.
      * value
        - Longfloat, the new slider value.
      * echo
        - Present if param had echo.
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Slider'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make a dropdown selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param:
      Table with the following items:
      * col
        - Integer, column to place the widget in.
      * cue
        - Cue to callback on interact event.
      * options
        - String, comma separated listing of selectable options.
      * start
        - Int, optional, index of the initially selected option.
      * echo
        - Optional, anything, returned on callback.
      
    onDropDownConfirmed event returns a table with:
      * row
        - Longfloat, row of the widget.
      * col
        - Longfloat, col of the widget.
      * option
        - Longfloat, the index of the selected option.
      * echo
        - Present if param had echo.
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Dropdown'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    General cue for packaging up a request and sending it to lua.
    This may be used instead of the Make_ command, by filling in a matching
    command name in the param table.
    
    Param:
      Table with the following items:
      * command
        - String, command to send to lua.
      * ...
        - Any args requied for the command.
  -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param" />
            
      <!-- If there is a callback cue, record it (should be a Make_ command). -->
      <!-- TODO: verify this is a Make_ command, and not something else that uses cue. -->
      <do_if value="$args.{'$cue'}?">
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <!-- Use a shallow copy for this, to avoid errors if the user reuses tables. -->
        <set_value name="Globals.$widget_properties.{Globals.$row}.{$args.{'$col'}}" exact="$args.clone" />
        
        <debug_text text="'Recorded callback to %s for row,col: (%s,%s)'.[$args.{'$cue'}, Globals.$row, $args.{'$col'}]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      
      <!-- 
        Construct the unified string of args.
        For future proofing, these will use named args, where name is comma
        separated from the value, and semicolons between args.
        Lua side will handle validation and defaults for optional args.
      -->
      <include_actions ref="Serialize_Args"/>
            
      <debug_text text="'Sending Process_Command with args: %s'.[$args_str]" 
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'" param="$args_str"/>
    </actions>
  </cue>
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets. Handle callbacks to user cues.
    
    The callback will echo the original widget args table, annotated with
    the data returned from lua. User code may use this feature to attach
    data to widgets at creation time, and use that echo'd data in
    callback handling.
        
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. This table will always have
    $row and $col of the widget the player modified, along with any
    per-widget state information.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
                
      <!-- Look up the callback cue for this row/col. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$args_table" exact="@Globals.$widget_properties.{$response.{'$row'}}.{$response.{'$col'}}" />
      <set_value name="$cue" exact="@$args_table.{'$cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
              
        <!-- Removed; switching to explicit $echo param.
          Add fields from the lua returned param to the args table.
          This could also add args to the lua response, but there are likely
          more args than lua table entries, so this form should be faster.          

        <do_all exact="$response.keys.list.count" counter="$i">
          <set_value name="$key" exact="$response.keys.list.{$i}" />
          <set_value name="$args_table.{$key}" exact="$response.{$key}" />
        </do_all>
        -->

        <!-- Add the $echo to the response. -->
        <do_if value="$args_table.{'$echo'}?">
          <set_value name="$response" exact="$args_table.{'$echo'}" />
        </do_if>
        
        <signal_cue_instantly cue="$cue" param="$response"/>
      </do_if>
      
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for row,col: (%s,%s)'.[$response.{'$row'}, $response.{'$col'}]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$options_submenu_specs.{'$'+$id}.{'$cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue"/>
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  <!--
    Listen for the lua signal of a closed standalone menu.
    event.param3 is a string, either "back" or "close", depending on
    if a back button was used or not.
  -->
  <cue name="Capture_Lua_Menu_Close" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'onCloseElement'" />
    </conditions>
    
    <actions>
      <!-- Look up the callback cue. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$menu_properties.{'$onClose_cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="event.param3" />
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu closing.'" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
</cues>

</mdscript>