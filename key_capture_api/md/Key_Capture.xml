<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Key_Capture"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <!--@doc-title Key Capture API -->
  <!--
MD API support for capturing key presses.
This makes use of the Named Pipe API and an external python server.
Python will handle keypress detection, and will transmit to this MD script
which in turn handles callbacks to user specified cues.

Goals:
 - Allow user to register a key with a cue.
 - When key pressed, call the user cue.
  
-->
  <!--
TODO:
  Test unregistering.
  
  Turn off server if all keys unregistered.

  Add an option to suppress further key matching when a key is held down,
  eg. ignore the extra 'press' events sent by the keyboard without a 'release'
  event.
  
  Add key context support, which situtions it is active:
    menu (test: hard to do, need to track signals from lua)
    space (test: not menu, player.occupiedship != null)
    firstperson (test: not menu, player.occupiedship == null)
  How to know when a menu is open (and not minimized)?
  - Listen to events for all possible menu names (as screen)
    Blank page: menu was opened (helper.lua line 872)
    'menu_closed' page: menu was closed (helper.lua line 1261)
  - Look up all registered menu names dynamically to be robust.
  - Lua side can give the menu names, but md has no apparent good way
    to read them in and set up cues (maybe spawn a listener cue instance
    for each lua message, one message per menu name?).
  - Alternatively, have lua patch into Helper to directly catch when
    a menu opens/closes (cleaner if robust).
    
-->
<cues>

  <!-- ################################################################## -->
  <!--                              Init                                  -->
  <!-- ################################################################## -->

    
  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                        param="'extensions.key_capture_api.lua.Key_Capture'"/>
    </actions>
  </cue>


  <!--
  Register the pipe server with the python host.
  -->
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly
        cue="md.Pipe_Server_Host.Register_Module"
        param="'extensions/key_capture_api/Send_Keys.py'"/>
    </actions>
  </cue>


  <!--
  Static cue that holds some shared state information or constants.
  When this script is installed, a new instance of this cue is created,
  and will afterwards be live until the script is removed.
  Globals reset each time the game is loaded, to enable easy changing
  of constants.
    
  * DebugChance
    - 0 or 100
    
  * shortcut_registry
    - Table of tables, with each subtable describing a shortcut.
    - Keys are the shortcut ids.
    - See Register_Shortcut for description of fields.
      
  * key_shortcut_registry
    - Table, indexed by key descriptor (string), holding a list of
      shortcut ids.
    - May have a mix of player-assigned and mod-assigned links.
    - Key descriptors have an extra '$' prefixed, due to x4 quirkiness.
    - Normally expect only one cue to be registered per key, but it
      might be higher.
    - Keys with no registered cues should be removed.
    - If table is empty, no keys are being listened to.
    - Note: this may be filled during init prior to shortcuts being
      registered, which is okay.
        
  * player_shortcut_keys
    - Table of player assigned key descriptors, keyed by shortcut id.
    - Saved across reloads.
    - Lua will have a mirrored copy of this, and is primarily responsible
      for changing it or initializing entries.
    - Note: a single shortcut may have multiple keys (2 through ui).
    - Each entry is a subtable with:
      * id
        - String, shortcut id.
      * inputs
        - List with two entries, subtables describing the key.
        - Indices match up to the menu columns (left/right), supporting two
          player keys per shortcut.
        - Fields per subtable:
          * combo
            - String, pipe server understood key combo.
            - Generated from the ego code.
          * code
            - Int, ego style key code.
            - See https://github.com/wgois/OIS/blob/master/includes/OISKeyboard.h
              for the code mapping.
          * source
            - Int, ego style input source type.  1 for keyboard.
          * signum
            - Int, ego style signum (signed prefix), generally 0.
            
  * menu_states
    - Table, keyed by menu name (as registered with ego backend), holding
      'true' if the menu is open, else 'false'.
    - Minimized menus will be treated as closed.
  * in_menu
    - Bool, true if the player has a menu open.
    - Updated whenever menu_states is changed, primarily to speedup checks
      during key handling.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
      Reset when the lua reloads.
      This is mostly aimed at helping with development/debug.
    -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Key_Capture'" control="'reloaded'" />
        </conditions>
        <actions>
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <set_value name="$shortcut_registry" exact="table[]"/>
      <set_value name="$key_shortcut_registry" exact="table[]"/>
      <set_value name="$menu_states" exact="table[]"/>
      <set_value name="$in_menu" exact="false"/>
      
      <!-- TODO: somehow bounce this over to Server_Reader reliably.-->
      <set_value name="$DebugChance" exact="100" />

      <!-- Init the $player_shortcut_keys if it doesn't exist. -->
      <set_value name="$player_shortcut_keys" exact="table[]"/>
      <do_if value="not $player_shortcut_keys?">
        <set_value name="$player_shortcut_keys" exact="table[]"/>
      </do_if>
        
      <!-- Otherwise re-register saved keys. -->
      <do_else>
        <do_all exact="$player_shortcut_keys.keys.list.count" counter="$i">
          <set_value name="$key" exact="$player_shortcut_keys.keys.list.{$i}"/>
          <signal_cue_instantly cue="Register_Key" param="table[
                                $key = $player_shortcut_keys.{$key}.$combo, 
                                $id  = $player_shortcut_keys.{$key}.$id,
                                ]"/>
        </do_all>
      </do_else>
        
      <!-- Init the lua with the stored list of player keys. -->
      <set_value name="player.entity.$key_capture_player_keys_from_md" exact="$player_shortcut_keys" />
      <raise_lua_event name="'Key_Capture.Update_Player_Keys'"/>        
        
    </actions>
  </library>
    


  <!-- ################################################################## -->
  <!--                          Pipe Handling                             -->
  <!-- ################################################################## -->

  <!-- 
  Use the generic server reader library to handle the pipe.
  Needs a cue wrapping it, else get property errors on the library refs.
    -->
  <cue name="Server_Reader_Wrapper">
    <cues>
      <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
        <param name="Actions_On_Init"     value="Actions_On_Init"/>
        <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
        <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
        <param name="Actions_On_Read"     value="Actions_On_Read"/>
      </cue>
    </cues>
  </cue>

  <library name="Actions_On_Init">
    <actions>
      <!--TODO: how to get debugchance from Globals safely on first mod load.-->
      <set_value name="$Pipe_Name" exact="'x4_keys'" />
      <set_value name="$DebugChance" exact="0" />
    </actions>
  </library>


  <library name="Actions_On_Reload">
    <actions>
      <include_actions ref="$Actions_On_Init"/>

      <!-- Send a signal that all users listen to. -->
      <!-- Removed; this signalling handled by Globals. -->
      <!--<signal_cue_instantly cue="md.Key_Capture.Reloaded"/>-->
    </actions>
  </library>


  <library name="Actions_On_Connect">
    <actions>
      <!-- Announce the wanted keys to the server. -->
      <signal_cue_instantly cue="md.Key_Capture.Register_Keys_With_Server_2"/>
    </actions>
  </library>

  <!--TODO: break out the key handling from the pipe cue.-->
  <library name="Actions_On_Read">
    <actions>
      <!-- Hand off to key_capture module cue. -->
      <signal_cue_instantly cue="md.Key_Capture.Handle_Key" param="event.param"/>

      <!--Acknowledge this key was read.
        Note: this will not bother to check for errors. If the pipe dies,
        a read will fail and catch it. -->
      <signal_cue_instantly
        cue="md.Named_Pipes.Write"
        param="table[$pipe=$Pipe_Name, $msg='ack']"/>
    </actions>
  </library>


  <!-- Function to update the server list of registered keys. -->
  <!-- Note: _2 in name is from switching this from lib to cue TODO: prune _2. -->
  <cue name="Register_Keys_With_Server_2" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Suppress if not connected to server, to reduce log confusion. -->
      <do_if value="Server_Reader.$server_connected == 1">

        <!--Start by merging the keys together, semicolon separated. -->
        <set_value name="$joined_keys" exact="''" />
        <do_all exact="Globals.$key_shortcut_registry.keys.list.count" counter="$i">
          <set_value name="$joined_keys"
            exact="$joined_keys + Globals.$key_shortcut_registry.keys.list.{$i} + ';'"/>
        </do_all>

        <!-- Send this to the server. -->
        <signal_cue_instantly
          cue="md.Named_Pipes.Write"
          param="table[$pipe = Server_Reader.$Pipe_Name, $msg = 'setkeys:'+$joined_keys ]"/>

      </do_if>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                           User API                                 -->
  <!-- ################################################################## -->


  <!--@doc-cue
  Dummy cue used for signalling that the api reloaded.
  Users that are registering shortcuts should listen to this
  cue being signalled.
  -->
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!--TODO: 'category name' for organizing keys better in the menu.-->
  <!--@doc-cue
  User function to register a shortcut. These shortcuts will be displayed
  in the api options menu for use assignment of a hotkey.
  This should be re-sent each time Reloaded is signalled.
    
  Param : Table with the following items:
  * id
    - String, unique identifier of this shortcut.
    - Saved keys will map to ids; other fields may be changed.
  * cue
    - The callback cue for when the shortcut is triggered.
  * name = id
    - String, name to use for the key in the menu.
    - If not given, defaults to the id.
  * description = ""
    - String, mouseover text use for the key in the menu.
  * contexts
    - Table holding the player contexts where the shortcut is valid.
    - If not given, defaults to "table{$flying = true}".
    - Fields:
      * flying
        - Bool, if the shortcut is valid while the player is piloting a ship.
      * walking
        - Bool, if the shortcut is valid while the player is on foot.
      * menu
        - Bool, if the shortcut is valid while the player is in any menu.
      * menu_names
        - List of names of menus where the shortcut is valid.
        - 'menu' is ignored if this is given.
      
  Keypress events will return a table with these fields:
  * id
    - Matching id of the shortcut. May be useful if one callback cue handles
      multiple shortcuts.
  * context
    - String, the player context when this shortcut was triggered.
    - Either one of ["flying", "walking", "menu"], or the name of the
      open menu matching an entry in menu_names.
    
  Usage example:
    ```xml
    <code>
      <cue name="Register_Shortcut" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Key_Capture.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Key_Capture.Register_Key" 
            param="table[
              $id   = 'my_key',
              $cue  = OnKeyPress,
              $name = 'Test Key',
              $description = 'This key is just testing',
              $contexts = table[ $flying = true, $walking = true ],
              ]"/>
        </actions>
      </cue>
    </code>
    ```
  -->
  <cue name="Register_Shortcut" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$args" exact="event.param"/>
      
      <!-- Default args. -->
      <do_if value="not $args.$description?">
        <set_value name="$args.$description" exact="''"/>
      </do_if>
      <do_if value="not $args.$name?">
        <set_value name="$args.$name" exact="$args.$id"/>
      </do_if>
      <do_if value="not $args.$contexts?">
        <set_value name="$args.$contexts" exact="table[$flying=true]"/>
      </do_if>
      <!-- In case menu_names was given as an empty list, remove it. -->
      <do_elseif value="$args.$contexts.$menu_names? and ($args.$contexts.$menu_names.count == 0)">
        <remove_value name="$args.$contexts.$menu_names"/>
      </do_elseif>
      
      <set_value name="Globals.$shortcut_registry.{'$'+$args.$id}" exact="$args"/>
        
      <!-- Keep the lua updated. -->
      <!-- Passes it on a player blackboard var, which lua clears. -->
      <set_value name="player.entity.$key_capture_shortcuts" exact="Globals.$shortcut_registry" />
      <raise_lua_event name="'Key_Capture.Update_Shortcuts'"/>
    </actions>
  </cue>


  <!--@doc-cue
  Function to register a key with a shortcut.
  If this is the first key registered, it will start the key listening loop.
  This is used by the menu system to set up player custom keys, but may
  also be called by a user to directly assign a key to a shortcut.
  Keys added by direct user calls will not be visible in the menu, and have
  fewer restrictions than the menu enforces.
  This should be re-sent each time Reloaded is signalled.
    
  Param  : Table with the following items:
    - key  : String specifying the key/combo to capture.
    - id   : String, id of the matching shortcut sent to Register_Shortcut.
      
  Usage example:
    <code>
      <cue name="Register_Keys" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Key_Capture.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Key_Capture.Register_Key" 
            param="table[$key='shift w', $id='my_registered_key']"/>
        </actions>
      </cue>
    </code>
    
  Key syntax:
  - Keys may be given singular or as a combination.
  - Combinations are space separated.
  - A combo is triggered when the last key is pressed while all prior keys
    are held.
    - Examples:
    - "shift ctrl k" : 'shift' and 'ctrl' held when 'k' pressed.
    - "space 5" : 'space' held when '5' pressed
  - Shift, alt, ctrl act as modifiers.
  - Alphanumeric keys use their standard character.
  - Special keys use these names (from pynput with some additions):
    - alt
    - alt_gr
    - alt_l
    - alt_r
    - backspace
    - caps_lock
    - cmd
    - cmd_l
    - cmd_r
    - ctrl
    - ctrl_l
    - ctrl_r
    - delete
    - down
    - end
    - enter
    - esc
    - f1 - f20
    - home
    - insert
    - left
    - menu
    - num_lock
    - page_down
    - page_up
    - pause
    - print_screen
    - right
    - scroll_lock
    - shift
    - shift_l
    - shift_r
    - space
    - tab
    - up
    - num_0
    - num_1
    - num_2
    - num_3
    - num_4
    - num_5
    - num_6
    - num_7
    - num_8
    - num_9
    - num_.
    - num_+
    - num_-
    - num_*
    - win_l
    - win_r
  - Note: numpad 'enter' and '/' alias to normal versions of those keys.

  -->
  <cue name="Register_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <!--<debug_text text="'params: %s.'.[event.param]" chance="Globals.$DebugChance" filter="general"/>-->

      <!-- Validate that a string was sent. Removed; buggy, typeof thinks some chars are not strings.
      <do_if value="(typeof event.param.$key) != datatype.string">
        <debug_text text="'Error, given key is not a string: %1'.[event.param.$key]"
                    chance="100" filter="error"/>
      </do_if> -->
       
      <!-- Adjust the key to prefix with a $ for x4 tables. -->
      <set_value name="$key" exact="'$' + event.param.$key"/>
      <set_value name="$id" exact="event.param.$id"/>

      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Globals.$key_shortcut_registry.{$key}?">
        <set_value name="Globals.$key_shortcut_registry.{$key}" exact="[]"/>
      </do_if>

      <!-- Check if the id is already recorded for this key. -->
      <do_if value="Globals.$key_shortcut_registry.{$key}.indexof.{$id} != 0">
        <!-- Print some warning. -->
        <debug_text text="'Warning, shortcut %s already registered to key %s.'.[$id, $key]"
                    chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      <do_else>
        <!-- It isn't recorded, so add it in. -->
        <append_to_list name="Globals.$key_shortcut_registry.{$key}" exact="$id" />
        <debug_text text="'Shortcut %s registered to key %s.'.[$id, $key]"
                    chance="Globals.$DebugChance" filter="general"/>
      </do_else>

      <!-- Update the server. If it isn't connected, ignore any error. -->
      <signal_cue_instantly cue="Register_Keys_With_Server_2"/>

      <!-- Make sure the read loop is started, if it wasn't already. -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
    </actions>
  </cue>


  <!--@doc-cue
  Function to unregister a key from a shortcut. 
  Params are the same as for Register_Key.
  If this was the only cue registered (across all keys), the key listerner
  loop will stop itself.
    
  Note: in development, untested.
    
  Usage example:
    <code>
      <signal_cue_instantly 
        cue="md.Key_Capture.Unregister_Key" 
        param="table[$key='w', $id='my_registered_key']">
    </code>
  -->
  <cue name="Unregister_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$key" exact="event.param.{'$key'}"/>
      <set_value name="$id" exact="event.param.{'$id'}"/>

      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Globals.$key_shortcut_registry.{$key}?">
        <!-- Print some warning. -->
        <debug_text text="'Warning, key %s has no registered shortcuts.'.[$key]"
                    chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      
      <do_else>
        <!-- Check if the id is recorded for this key. -->
        <set_value name="$id_index" exact="Globals.$key_shortcut_registry.{$key}.indexof.{$id}"/>
        <do_if value="$id_index == 0">
          <!-- It isn't recorded, so print a warning. -->
          <debug_text text="'Warning, shortcut %s is not registered to key %s.'.[$id, $key]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_if>

        <do_else>
          <!-- Proceed with removal. -->
          <remove_value name="Globals.$key_shortcut_registry.{$key}.{$id_index}" />
          <debug_text text="'Removed shortcut %s from key %s.'.[$id, $key]"
                      chance="Globals.$DebugChance" filter="general"/>

          <!-- If the key's cue list is empty, also remove the key itself. -->
          <do_if value="Globals.$key_shortcut_registry.{$key}.count == 0">
            <remove_value name="Globals.$key_shortcut_registry.{$key}" />
            <debug_text text="'No remaining listeners to key %s; removing it.'.[$key]"
                        chance="Globals.$DebugChance" filter="general"/>

            <!-- Update the server. If it isn't connected, ignore any error. -->
            <signal_cue_instantly cue="Register_Keys_With_Server_2"/>
          </do_if>
        </do_else>
      </do_else>

    </actions>
  </cue>



  <!-- ################################################################## -->
  <!--                          Lua events                                -->
  <!-- ################################################################## -->

  <!--
    Capture lua signals when the player assigns a new key.
      
    Lua's passed param will be a table with:
    * new_key
      - New key combo, or blank string.
    * old_key
      - Prior key combo, or blank string.
    * id
      - Shortcut id
  -->
  <cue name="Capture_Lua_Key_Update" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Key_Capture'" control="'Update_Key'" />
    </conditions>

    <actions>
      <!-- Rename the args. -->
      <set_value name="$args" exact="event.param3" />
      <debug_text text="'Args: %s'.[$args]" chance="Globals.$DebugChance" filter="general"/>

      <!-- If there was a prior key, unregister it. -->
      <do_if value="$args.$old_key != ''">
        <signal_cue_instantly cue="Unregister_Key" 
                              param="table[$key=$args.$old_key, $id=$args.$id]"/>
      </do_if>

      <!-- If there is a new key, register it. -->
      <do_if value="$args.$new_key != ''">
        <signal_cue_instantly cue="Register_Key" 
                              param="table[$key = $args.$new_key, $id = $args.$id]"/>
      </do_if>

    </actions>
  </cue>


  <!--
    Capture lua signals to store the list of player keys.
    Generally called at the same time as Update_Key, but kept separate
    for now.
    The keys are passed on the player blackboard.
  -->
  <cue name="Capture_Lua_Store_Player_Keys" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Key_Capture'" control="'Store_Player_Keys'" />
    </conditions>
    <actions>
      <set_value name="Globals.$player_shortcut_keys" 
                 exact="player.entity.$key_capture_player_keys_from_lua"/>
      <remove_value name="player.entity.$key_capture_player_keys_from_lua"/>
    </actions>
  </cue>

  <!--
    Capture menu open/close events.
    This updates menu_states and in_menu.
  -->
  <library name="Lib_Update_Menu_Status">
    <actions>
      <!--Set the flag false initially, back to true on any menu open.-->
      <set_value name="Globals.$in_menu" exact="false"/>
      <do_all exact="Globals.$menu_states.keys.list.count" counter="$i">
        <set_value name="$key" exact="Globals.$menu_states.keys.list.{$i}"/>
        <do_if value="Globals.$menu_states.{$key}">
          <set_value name="Globals.$in_menu" exact="true"/>
        </do_if>
      </do_all>
      <!--<debug_text text="'Globals.$in_menu = %1'.[Globals.$in_menu]"
                  chance="Globals.$DebugChance" filter="general"/>-->
    </actions>
  </library>
  
  <cue name="Capture_Lua_Menu_Opened" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Key_Capture'" control="'Menu_Opened'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="true"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
  
  <cue name="Capture_Lua_Menu_Closed" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Key_Capture'" control="'Menu_Closed'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="false"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                         Key Press Handling                         -->
  <!-- ################################################################## -->

  <!--
    Handle a key press event.
    The key code should be in event.param.
  -->
  <cue name="Handle_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>      
      <!-- Read succeeded with at least one key. -->
      <!-- Handle callback cues. -->
      <!-- TODO: support multiple keys returned, with some separator. -->

      <!-- Start by prefixing the key combo with a '$' for table lookups. -->
      <set_value name="$key" exact="'$' + event.param"/>
      <debug_text text="'Received key %s.'.[$key]"
                  chance="Globals.$DebugChance" filter="general"/>

      <!-- Is the key returned actually registered? -->
      <do_if value="Globals.$key_shortcut_registry.{$key}?">
        
        <!-- Determine the current player context. -->
        <!-- TODO: maybe pack into chained if/then/else expression. -->
        <!-- If any menu is open, then in a menu. -->
        <do_if value="Globals.$in_menu">
          <set_value name="$context" exact="'$menus'"/>
        </do_if>
        <!-- Otherwise if piloting a ship, then flying. -->
        <do_elseif value="player.occupiedship">
          <set_value name="$context" exact="'$flying'"/>
        </do_elseif>
        <!-- Otherwise walking around. -->
        <do_else>
          <set_value name="$context" exact="'$walking'"/>
        </do_else>

        
        <!-- Convenience renaming of shortcut ids. -->
        <set_value name="$id_list" exact="Globals.$key_shortcut_registry.{$key}"/>
        <!-- Loop over the shortcut ids. -->
        <do_all exact="$id_list.count" counter="$i">
          <!-- Get the actual shortcut info. -->
          <set_value name="$shortcut" exact="Globals.$shortcut_registry.{'$'+$id_list.{$i}}"/>
          
          <!-- Determine if this shortcut is valid at this time. -->
          <set_value name="$valid" exact="false"/>
          
          <!-- If in menu and a menu_list was given, check specific menu names. -->
          <do_if value="Globals.$in_menu and ($shortcut.$contexts.$menu_names?)">
            <!-- Go through all menu names and see if any are open. -->
            <do_all exact="$shortcut.$contexts.$menu_names.count" counter="$j">
              <!--Convenience renaming. TODO: prefix with $ at registration.-->
              <set_value name="$menu_name" exact="'$'+$shortcut.$contexts.$menu_names.{$j}"/>
              <!--Check this is a tracked menu, and in an open state.-->
              <do_if value="Globals.$menu_states.{$menu_name}? and Globals.$menu_states.{$menu_name}">
                <!-- This menu is open, so flag as valid. -->
                <set_value name="$valid" exact="true"/>
                <!-- Update the context for cue callback. -->
                <set_value name="$context" exact="$menu_name"/>
              </do_if>
            </do_all>
          </do_if>
          
          <!-- Otherwise general context check. User may not have specified all contexts. -->
          <do_elseif value="$shortcut.$contexts.{$context}? and $shortcut.$contexts.{$context}">
            <!-- If here, got a context match. -->
            <set_value name="$valid" exact="true"/>
          </do_elseif>
          
          <!-- While context might be valid, there could be other problems. -->
          <!-- Clear the $valid if the cue wasn't given or doesnt exist. -->
          <set_value name="$cue" exact="@$shortcut.$cue"/>
          <set_value name="$valid" exact="if ($cue.exists) then ($valid) else (false)"/>
          <!-- TODO: delink keys from non-existent shortcuts/cues. -->
          
          <!-- If valid is still true, can call the cue. -->
          <do_if value="$valid">            
            <!-- Call the cue, with return values. -->
            <signal_cue_instantly cue="$cue" param="table[
                                  $id = $id_list.{$i},
                                  $context = $context,
                                  ]"/>
          </do_if>          
        </do_all>
      </do_if>

      <do_else>
        <!-- Key not registered. TODO: error message. -->
      </do_else>
    </actions>
  </cue>

    
  </cues>
</mdscript>