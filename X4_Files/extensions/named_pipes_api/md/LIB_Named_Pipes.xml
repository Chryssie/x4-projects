<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="LIB_Named_Pipes" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">

<!--
MD API support for working with named pipes for inter-process communication.
This will tie into related functions in an accompanying lua script.

Note: for Windows named pipes. Linux support may or may not come later.

Goals:
  - Allow user to open a named pipe, with arbitrary name.
  - Handle pipe write and read requests.
  - Track active pipe accesses, and recover correctly after save/reload
    when an access was in flight. Eg. a read request sent that hasn't
    returned a value yet when a game is saved, will be resent after
    reloading.
  - Any other techniques to improve reliability, transparent to user.
  
Operation notes:
  - Pipe objects will be tracked in a shared table, stored in a static cue
    in this library.
  - The actual OS level pipe connections are handled in lua, and checked
    on every access.
  - Users may open or close pipes by signalling appropriate library cues,
    which carry out the action and close, with pipes being added or removed
    from the shared table appropriately.
  - Users interract with the pipes by signalling appropriate service cues.
  - Where necessary, pipe return results are passed to callback cues
    provided by the user.
  
    
TODO: maybe add a callback for Write to capture success/failure.

TODO: a command or memory style interface, eg. Set/Get, where all reads
      are preceeding by some sort of command written that triggers a
      response in the server.

TODO: maybe a generic function to check if the pipe is open.

TODO: a more robust way to buffer up writes/reads, get acknowledgements,
      resend requests that are not acknowledged, etc.
    
-->
<cues>

  <!-- 
    Setting up the Lua side of this test.
    This uses the _G workaround mod, which has a bit of extra setup.
  -->
  <cue name="RegisterUI" version="1" instantiate="true">
    <conditions>
      <event_cue_completed cue="md.G_Work_Around.Init"/>
    </conditions>
    <actions>
      <raise_lua_event name="'RegisterAddon'"
                       param="'extensions.named_pipes_api.Named_Pipes'"/>
    </actions>
  </cue>
  
  
  <!--
    Static cue that tracks all opened pipes, makes connections, etc.
    This is primarily intended for local usage.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    
    Attributes:
    * $pipe_table
      - Table of opened (but maybe not connected) pipe descriptors.
      - Keyed by pipe name, holding a subtable of attributes.
      - TODO: think about what goes into a pipe descriptor.
    * $pipe_name_prefix
      - String, prefix to add to all pipe names to construct the OS path.
      - On windows, this is "\\.\pipe\"
  -->
  <cue name="Pipe_Manager">
  
    <!-- Set up static variables. -->
    <actions>
      <set_value name="$pipe_table" exact="table[]" />
      <!-- Prefix to add to all pipe names. -->
      <set_value name="$pipe_name_prefix" exact="'\\\\.\\pipe\\'" />
    </actions>
    
    <cues>
      <!--When a save is loaded, reconnect/reset the pipe, and resend any
          pending requests.
          -->
      <cue name="Handle_Game_Reload" instantiate="true">
        <conditions>
          <event_game_loaded/>
        </conditions>
        <actions>
          <!-- Loop over any open pipes. TODO -->
        </actions>
      </cue> <!-- end Handle_Game_Reload -->
    </cues>
  </cue> <!-- end Pipe_Manager -->
  
  
  
  <!--
    User function to register a new pipe for opening.
    If the pipe already was opened, this will do nothing.
    Note: the OS pipe may or may not actually be connected to (and may not
    even exist at this point), though the pipe will be added to appropriate
    tables to support future access attempts.
    Called through signal_cue_instantly.
    
    Note: currently this is not needed for early testing, as Read/Write
    cause Lua to open the pipe automatically.
    
    TODO: consider making this auto-open more formal. Tradeoff
    is that it is easier to mess up a pipe name without an error, and the
    mistaken name would get added to the pipe table, polluting it somewhat,
    possibly countered by the pipe table occasionally cleaning out pipes
    that haven't been used in a while (eg. since last save game was loaded).
    
    Args:
      param  : List with one item:
        0: String, name of the pipe being opened, with no OS prefix.
      
    Returns:
      nothing.
    
    Usage example:
      <signal_cue_instantly name="md.LIB_Named_Pipes.Open" param="['mypipe']">
  -->
  <cue name="Open" instantiate="true">
    <!-- Activate only when signalled; no extra filters.-->
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Save input args (since 'event' is not available in subcues). -->
      <set_value name="$pipe_name" exact="event.param.{1}" />
      
      <!-- Check if a pipe of this name already exists.
          Note: strings as keys literally must start with $)-->
      <do_if value="Pipe_Manager.$pipe_table.{'$'+$pipe_name}?">      
        <!-- Debug announcement to the chat window. -->
        <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name + ' already open'"/>
      </do_if>
      <do_else>
        <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name + ' opened'"/>
        
        <!-- Init a new pipe table entry. -->
        <set_value  name="Pipe_Manager.$pipe_table.{'$'+$pipe_name}" 
                    exact="table[{'$name'} = $pipe_name, {'$pending_reads'} = [], {'$connected'} = 0]"/>
        <!-- <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;key test:' + Pipe_Manager.$pipe_table.keys.list "/> -->
      </do_else>

    </actions>
  </cue> <!-- end Open -->
  
  
  <!--
    User function to close a pipe.
    Does nothing if the pipe does not exist.
    
    Called through signal_cue_instantly.
    
    Args:
      param  : List with one item:
        0: String, name of the pipe being opened, with no OS prefix.
      
    Returns:
      nothing.
    
    Usage example:
      <signal_cue_instantly name="md.LIB_Named_Pipes.Close" param="['mypipe']">
  -->
  <cue name="Close" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Save input args (since 'event' is not available in subcues). -->
      <set_value name="$pipe_name" exact="event.param.{1}" />
      
      <!-- Check if a pipe of this name already exists. -->
      <do_if value="Pipe_Manager.$pipe_table.{'$'+$pipe_name}?">
        <!-- TODO: any cleanup/flush stuff. Signal lua to close the file. -->
        <!-- Remove the table entry. -->
        <remove_value name="Pipe_Manager.$pipe_table.{'$'+$pipe_name}" />
        <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name + ' closed'"/>
      </do_if>
      <do_else>
        <!-- Debug announcement to the chat window. -->
        <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name + ' not open; cannot close'"/>        
      </do_else>

    </actions>
  </cue> <!-- end Close -->
  
  
  <!--
    User function to write a pipe.
    Called through signal_cue_instantly.
    
    Args:
      param  : List with two items:
        0: String, name of the pipe being written.
        1: Message to write to the pipe.
      
    Returns:
      nothing.
    
    Usage example:
      <signal_cue_instantly name="md.LIB_Named_Pipes.Write" param="['mypipe', 'hello']">
  -->
  <cue name="Write" instantiate="true">
    <!-- Activate only when signalled; no extra filters.-->
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Save input args (since 'event' is not available in subcues). -->
      <set_value name="$pipe_name" exact="event.param.{1}" />
      <set_value name="$message" exact="event.param.{2}" />
      
      <!-- Debug announcement to the chat window. -->
      <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name +' writing: ' + $message"/>

      <!--Trigger the lua handler.
          Awakwardly, this only accepts one param, so the pipename and message
          need to be squished together. -->
      <raise_lua_event name="'pipeWrite'" param="Pipe_Manager.$pipe_name_prefix + $pipe_name + ';' + $message"/>       
    </actions>
    
    <!-- TODO: any sort of ack callback. -->
  </cue> <!-- end Write -->
  
  
  <!--
    User function to read a pipe.
    Called through signal_cue_instantly.
    
    Args:
      param  : List with two items:
        0: String, name of the pipe being written.
        1: Cue, the cue to call when the read completes. This has no $.
      
    Returns:
      Whatever is read from the pipe in event.param to the callback cue.
      If the read fails for some reason, this will be an 'ERROR' string.
    
    Usage example:
      <signal_cue_instantly name="md.LIB_Named_Pipes.Read" param="['mypipe', MyReadHandler]">      
      ...
      <cue name="MyReadHandler" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <actions>
          <set_value name="$read_result" exact="event.param"/>
          <do_if value="$read_result == 'ERROR'">
            <stuff to do on pipe error>
          </do_if>
          <do_else>
            <stuff to do on read success>
          </do_else>
        </actions>
      </cue>
      
  TODO: make safe against refreshmd, reloadui, save/reload
  -->
  <cue name="Read" instantiate="true">
    <!-- Activate only when signalled; no extra filters.-->
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Save input args (since 'event' is not available in subcues). -->
      <set_value name="$pipe_name" exact="event.param.{1}" />
      <set_value name="$callback_cue" exact="event.param.{2}" />
      
      <!-- Debug announcement to the chat window. -->
      <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name +' read started'"/>

      <!-- Trigger the lua handler. -->
      <raise_lua_event name="'pipeRead'" param="Pipe_Manager.$pipe_name_prefix + $pipe_name"/>       
    </actions>
    
    <cues>
      <!--
      Capture the result.
      This is handled by a lua created object event, sent to the galaxy,
      suffixed by the pipe name.
      -->
      <cue name="Capture_Read_Response" instantiate="true">
        <conditions>
          <event_object_signalled object="player.galaxy" param="'pipeRead_'+$pipe_name"/>
        </conditions>
        
        <actions>              
          <!-- Grab the returned value. -->
          <set_value name="$response" exact="event.param2" />
          
          <!-- Debug announcement to the chat window. -->
          <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ $pipe_name +' returned: ' + $response "/>
          
          <!-- An ERROR may have been returned. Ignore for now. -->
          
          <!-- Signal the callback cue with this response. -->
          <signal_cue_instantly cue="$callback_cue" param="$response"/>
          
        </actions>        
      </cue> <!-- end Capture_Read_Response -->
      
    </cues>
  </cue> <!-- end Read -->
  
</cues>

</mdscript>