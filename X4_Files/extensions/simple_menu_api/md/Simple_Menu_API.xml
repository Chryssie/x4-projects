<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xsi:noNamespaceSchemaLocation="md.xsd">

<!--
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

Note on raise_lua_event param:
- Can pass:
  string
  integer (becomes number)
  float (becomes number)
- Can't pass:
  table (becomes nil)
  list (becomes nil)

-->
  
<cues>

  <!-- Register the lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.simple_menu_api.Simple_Menu'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * row
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * callback_cues
      - Table of tables of callback cues provided by the user for widget events.
      - Outer table keyed by widget row, inner table by widget column.
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu..
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Named_Pipes'" control="'reloaded'" />
        </conditions>
        <actions>
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="100" />
      <set_value name="Globals.$callback_cues" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />      
    </actions>
  </library>

  
  <!--
    Dummy cue used for signalling.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


  <!-- 
    Helper lib function to do some processing on user provided call args.
    The original event.param should be placed in $args, and the associated
    command name placed in $command.
    
    If the user event/param was none, this makes a default table first.
    -->
  <library name="Process_Args">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
      <!-- Add the command to it. -->
      <set_value name="$args.{'$command'}" exact="$command"/>
      
      <!-- If there is a callback cue, record it. -->
      <do_if value="$args.{'$cue'}?">
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <set_value name="Globals.$callback_cues.{Globals.$row}.{$args.{'$col'}}" exact="$args.{'$cue'}" />
        
        <debug_text text="'Recorded callback to %s for row,col: (%s,%s)'.[$args.{'$cue'}, Globals.$row, $args.{'$col'}]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      
    </actions>
  </library>
  
  
  <!-- 
    Serializes an args table into a string, for passing to lua.
    The table should be flat, with no subtables or sublists.
    
    Input table should be in $args.
    Results strings is in $args_str.
    Overwrites $i, $key, $value.
    -->
  <library name="Serialize_Args">
    <actions>
      <set_value name="$args_str" exact="''" />
              
      <!-- Loop over the param table's keys. -->
      <do_all exact="$args.keys.list.count" counter="$i">
        <!-- Isolate key and value. -->
        <set_value name="$key" exact="$args.keys.list.{$i}" />
        <set_value name="$value" exact="$args.{$key}" />
        
        <!-- 
          Add to the running args string. Add prefix semicolon after first arg.
          This makes separting in lua a bit easier.
          -->
        <do_if value="$i != 1">
          <set_value name="$args_str" exact="$args_str + ';'" />
        </do_if>
        <!-- Add to the running args string. -->
        <set_value name="$args_str" exact="$args_str + $key + ',' + $value" />
      </do_all>
    </actions>
  </library>
  
  <!--
    Register an options menu, which will be accessible as a submenu of
    the normal game options.
    
    Param:
      Table with the following items:
      * $id
        - String, unique identifier for this menu.
        - Needs to differ from egosoft menu names, as well as any other
          mod registered menus.
      * $title
        - Text to display in the table header.
      * $columns
        - Integer, total number of columns in the menu table.
      * $cue
        - Cue to be called when the submenu needs to be built.
        - This cue should use addRow and makeX functions to build the menu.
        - Do not call Create_Menu from this cue.
      * $private
        - Int 0 or 1, optional, controls if the menu will be listed automatically
          in the general list of Extension Options menus.
        - Defaults to 0, non-private.
        - Set to private for submenus you will manually link to using
          Add_Submenu_Link.
                
    Call this each time the Reloaded cue is signalled. Example:
    
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $cue     = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Select an id for the menu, based on the next spec index. -->
      <!-- <set_value name="event.param.{'$id'}" exact="Globals.$options_submenu_specs.count +1" /> -->
      
      <!-- Record the args using the menu id, $ prefixed. -->
      <set_value  name="Globals.$options_submenu_specs.{'$'+event.param.{'$id'}}" exact="event.param" />
      
      <!-- Convert the table to a string. -->
      <set_value name="$args" exact="event.param" />
      <include_actions ref="Serialize_Args"/>
            
      <debug_text text="'Sending Register_Options_Menu with args: %s'.[$args_str]" 
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Register_Options_Menu'" param="$args_str"/>
    </actions>
  </cue>
  
  
  <!--
    Create a fresh menu, with just a header.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Param:
      Table with the following items:
      * columns
        - Integer, total number of columns in the menu table.
      * title
        - Text to display in the table header.
      * height
        - Int, optional, menu height. Default expands to fit contents.
      * width
        - Int, optional, menu width. Defaults to a predefined width.
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Reset old state. -->
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$callback_cues" exact="table[]" />
      
      <set_value name="$command" exact="'Create_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Close_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Display the menu.
    Mainly for use with options menus, which requires this to know when
    all build commands are complete.
    -->
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Display_Menu'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu.
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * menu_id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Add_Submenu_Link'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--
    Add a row to the current menu.
    Following Make_ commands add to the most recently added row.
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Update the row count, and expand the callback table. -->
      <set_value name="Globals.$row" exact="Globals.$row + 1" />
      <set_value name="Globals.$callback_cues.{Globals.$row}" exact="table[]" />
      
      <set_value name="$command" exact="'Add_Row'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Make a label cell for displaying text.
    Adds to the most recent row.
    
    Param:
      Table with the following items:
      - col       : Integer, column to place the widget in.
      - text      : Text to display, without semicolons.
      - mouseover : Optional, extra text to display on mouseover.
    -->
  <cue name="Make_Label" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Label'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Make a pressable button cell.
    Adds to the most recent row.
    
    Param:
      Table with the following items:
      - col       : Integer, column to place the widget in.
      - cue       : Cue to callback on interact event.
      - text      : Text to display, without semicolons.
      
    onClick event returns a table with:
      - row       : Longfloat, row of the widget.
      - col       : Longfloat, col of the widget.
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Button'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Make a edit box cell, for text entry.
    Adds to the most recent row.
    Every letter change will trigger a callback.
    
    Param:
      Table with the following items:
      - col       : Integer, column to place the widget in.
      - cue       : Cue to callback on interact event.
      - text      : Optional, initial text to display, without semicolons.
      
    onTextChanged event returns a table with:
      - row       : Longfloat, row of the widget.
      - col       : Longfloat, col of the widget.
      - text      : String, new text in the box.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_EditBox'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Make a horizontal slider cell.
    Adds to the most recent row.
    Every slider adjustment (many per sweep) triggers a callback.
    
    Param:
      Table with the following items:
      - col            : Integer, column to place the widget in.
      - cue       : Cue to callback on interact event.
      - min            : Int, min value.
      - minSelect      : Int, optional, min selectable value if different than min.
      - max            : Int, max value.
      - maxSelect      : Int, optional, max selectable value if different than max.
      - start          : Int, initial value.
      - step           : Int, step size.
      - suffix         : String, optional, suffix displayed on the value, eg. " %".
      
    onSliderCellChanged event returns a table with:
      - row       : Longfloat, row of the widget.
      - col       : Longfloat, col of the widget.
      - value     : Longfloat, the new slider value.
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Slider'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Make a dropdown selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param:
      Table with the following items:
      - col       : Integer, column to place the widget in.
      - cue       : Cue to callback on interact event.
      - options   : String, comma separated listing of selectable options.
      - start     : Int, optional, index of the initially selected option.
      
    onDropDownConfirmed event returns a table with:
      - row       : Longfloat, row of the widget.
      - col       : Longfloat, col of the widget.
      - option    : Longfloat, the index of the selected option.
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$command" exact="'Make_Dropdown'"/>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Process_Args"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--
    Local cue for packaging up a request and sending it to lua.
    Handles param packing into a string, and filling optional fields.
    
    Param:
      Table with the following items:
      - command   : String, command to send to lua.
      - ...       : Any args requied for the command.
  -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- 
        Construct the unified string of args.
        For future proofing, these will use named args, where name is comma
        separated from the value, and semicolons between args.
        Lua side will handle validation and defaults for optional args.
      -->
      <set_value name="$args" exact="event.param" />
      <include_actions ref="Serialize_Args"/>
            
      <debug_text text="'Sending Process_Command with args: %s'.[$args_str]" 
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'" param="$args_str"/>
    </actions>
  </cue>
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets.  Pass results to the user provided callback for the widget.
    
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. This table will always have
    $row and $col of the widget the player modified, along with any
    per-widget state information.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
                
      <!-- Look up the callback cue for this row/col. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$callback_cues.{$response.{'$row'}}.{$response.{'$col'}}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="$response"/>
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for row,col: (%s,%s)'.[$response.{'$row'}, $response.{'$col'}]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$options_submenu_specs.{'$'+$id}.{'$cue'}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue"/>
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
</cues>

</mdscript>