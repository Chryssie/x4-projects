<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="LIB_Key_Capture" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">

<!--
MD API support for capturing key presses.
This makes use of the Named Pipe API and an external python server.
Python will handle keypress detection, and will transmit to this MD script
which in turn handles callbacks to user specified cues.

Goals:
  - Allow user to register a key with a cue.
  - When key pressed, call the user cue.
  
  
TODO:
  Switch to not saving keys across reloads, requiring they be reset regularly.
  This would add robustness against mods being removed, so their old keys
  aren't remembered. (Alternative is to check if callback cues exist anymore,
  but that is less robust if a mod hooked a key to some external cue not
  part of that mod, or if a mod changes how it does key announcement but
  the cue still exists.)
  
  Require keys be re-registered in a particular way, eg. on some cue being
  signalled (or later).
  
  
Question: what general approach to use?

  A)  Have a global table of keys registers, subtables of cues to be called.
      Global handler announces to server keys it cares about, and signal
      names to use for those keys being pressed.
      Global handler responsible for setting up instanced listeners for
      each registered key, which in turn signal the respective cues.
      
      - One listener per key, even if multiple cues hook into it.
      - Extra complexity for multiple cues/key, when generally only expect
        one cue/key.
         
      Unregistering a key/cue means removing that cue from the key table.
      If a key has no callback cues, stop the listener in some way?
      May need to code this check into the listener in some way, but it is
      an instance, so unclear on how to do this.
       
  B)  Have an independent key register cue, which instantiates a listener.
      No global registery.
      Still has the quirk of difficulty unregistering a key/cue, but might
      be even more complicated than above.
     
  C)  Global handler as in A, but only one listener for key presses.
      When getting a keypress, the listener checks it against key/cue
      table, and signals cues.
      Unregistering relatively easy, just remove cue from key table.
      Probably okay to leave listener running even if no keys registered.
      Might have better peformance, since MD engine doesn't need to track
      so many subcues.
      
  Going with C, as it seems easiest to manage.
  
  
Question: should this save registered keys, or require users to re-register
  on each game reload?
  
  This api is easier to write if it doesn't have to keep state, but that
  would make it harder to use.
  There is no particular expectation that reloading a save should break
  keys, so it makes most sense to save them.
  This api will then need to be responsible for re-informing the server
  when it is reset of which keys to capture.
  
  However, saving the state here makes it less robust against version
  changes, as it removes freedom to rename variables, add new table
  fields, etc., except through the annoying patching system.
  
  Compromise: save the specific key/cue combos registered, but keep them
  in their own data table and add nothing else to it.  All other state
  can be rebuilt on reload.
     
     
     
Overview of cues and what they call:

  Globals
  - Set up once at lib setup, storing static important state.
  -> Globals.Reset_On_Lua_Reload
    - Updates some settings, eg. DebugChance.
  
  Register_Key (called by user)
  - Sends new key list to server.
  -> Activate_Read_Loop (does nothing if ping/read loops are active).
  
    -> Ping_Server: Sends dummy write to server.
      -> Ping_Callback      
        On error:
          If keys are still registered:
          -> Ping_Server_With_Delay (short delay, several seconds)
            -> Ping_Server (loops)
          else does nothing, loop dies.          
        On success:
        - Sends current key list to server.
        -> Read_Key
          -> Read_Callback
            On timeout:
              If keys are still registered:
              -> Read_Key (loops)
              else does nothing, loop dies.
            On error:
              -> Ping_Server
            Else:
              -> User callbacks for the key(s) from server.
              -> Read_Key (loops)
    
    
  Unregister_Key (called by user)
  - Sends new key list to server.
  - Calls no other cues; Read_Key_Callback checks if keys still registered.
    
-->
<cues>
  
  <!--
    Register the pipe server with the python host.
  -->  
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.LIB_Pipe_Server.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly 
        cue="md.LIB_Pipe_Server.Register_Module" 
        param="'extensions/key_capture_api/Send_Keys.py'"/>
    </actions>
  </cue>
      
  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals partially reset each time the game is loaded, to enable easy
    changing of some constants.
    
    Attributes:
    * key_cue_registry
      - Table, indexed by key descriptor (string), holding lists of cues.
      - Key descriptors have an extra '$' prefixed, due to x4 quirkiness.
      - Normally expect only one cue to be registered per key, but it
        might be higher.
      - Keys with no registered cues should be removed.
      - If table is empty, no keys are being listened to.
      - Saved across reloads.
    * server_access_loop_active
      - Flag, 1 when either the Ping_Server or Read_Key loops are active
        and waiting for a pipe access callback (or in a delay node).
      - If 0, the loops are stopped, and Ping_Server should be called
        to start them.
      - Saved across reloads.
    * DebugChance
      - 0 or 100
      - Reloaded
      
    TODO: move pipe_name to here instead of hardcoding it.
  -->  
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <!-- TODO: move towards not saving these. -->
      <set_value name="$key_cue_registry" exact="table[]" />
      <set_value name="$server_access_loop_active" exact="0"/>
      <include_actions ref="Reset_Globals"/>
    </actions>
  </cue>
  
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="$DebugChance" exact="100" />
    </actions>
  </library>

  <!--
    Reset some vars and send a signal when the pipe api reloads.
    
    TODO: maybe switch to waiting on the pipe server api to reload first.
  -->
  <cue name="Reset_On_Lua_Reload" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.LIB_Named_Pipes.Reloaded" />
    </conditions>
    <actions>
      <!-- Make sure the global registry is reset. -->
      <include_actions ref="Reset_Globals"/>
      <!-- Send a signal that all users listen to, to repopulate the table. -->
      <signal_cue_instantly cue="Reloaded"/>
    </actions>
  </cue>  
  
  <!--
    Dummy cue used for signalling.
    TODO: have users re-register their keys when this signal is sent,
    instead of saving keys here.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


      
  <!--
    User function to register a key with a cue.
    If this is the first cue registered, it will start the key listening loop.
    
    Param  : Table with the following items:
      key  : String specifying the key/combo to capture.
             TODO: document key syntax.
      cue  : Callback, the cue to call when the key is pressed.
      
    Returns:
      Nothing directly.
      Callback cue will be given the key pressed in event.param.
    
    Usage example:
      <signal_cue_instantly cue="md.LIB_Key_Capture.Register_Key" param="table[$key='w', $cue=OnKeyPress]">
  -->
  <cue name="Register_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Adjust the key to prefix with a $ for x4 tables. -->
      <set_value name="$key" exact="'$' + event.param.{'$key'}"/>
      <set_value name="$cue" exact="event.param.{'$cue'}"/>
      
      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Globals.$key_cue_registry.{$key}?">
        <set_value name="Globals.$key_cue_registry.{$key}" exact="[]"/>
      </do_if>
      
      <!-- Check if the cue is already recorded for this key. -->
      <do_if value="Globals.$key_cue_registry.{$key}.indexof.{$cue} != 0">
        <!-- Print some warning. -->
        <debug_text text="'LIB_Key_Capture.Register_Key: Warning, cue %s already registered to key %s.'.[$cue.name, $key]" chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      <do_else>
        <!-- It isn't recorded, so add it in. -->
        <append_to_list name="Globals.$key_cue_registry.{$key}" exact="$cue" />
        <debug_text text="'LIB_Key_Capture.Register_Key: cue %s registered to key %s.'.[$cue.name, $key]" chance="Globals.$DebugChance" filter="general"/>
        <!-- <raise_lua_event name="'directChatMessageReceived'" param="'Pipes;'+ event.param + ' closing if open.'"/> -->
      </do_else>
      
      <!-- Update the server. If it isn't connected, ignore any error. -->
      <include_actions ref="Register_Keys_With_Server"/>
      
      <!-- Make sure the read loop is started, if it wasn't already. -->
      <include_actions ref="Activate_Read_Loop"/>
      
    </actions>    
  </cue>
  
    
  <!--
    User function to unregister a key/cue. 
    Params are the same as for Register_Key.
    If this was the only cue registered (across all keys), the key listerner
    loop will stop itself.
    
    Usage example:
      <signal_cue_instantly cue="md.LIB_Key_Capture.Unregister_Key" param="table[$key='w', $cue=OnKeyPress]">
  -->
  <cue name="Unregister_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <set_value name="$key" exact="event.param.{'$key'}"/>
      <set_value name="$cue" exact="event.param.{'$cue'}"/>
      
      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Globals.$key_cue_registry.{$key}?">
        <!-- Print some warning. -->
        <debug_text text="'LIB_Key_Capture.Unregister_Key: Warning, key %s has no registered cues.'.[$key]" chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      
      <!-- Check if the cue is recorded for this key. -->
      <set_value name="$cue_index" exact="Globals.$key_cue_registry.{$key}.indexof.{$cue}"/>
      <do_if value="$cue_index == 0">
        <!-- It isn't recorded, so print a warning. -->
        <debug_text text="'LIB_Key_Capture.Unregister_Key: Warning, cue %s is not registered to key %s.'.[$cue.name, $key]" chance="Globals.$DebugChance" filter="general"/>
      </do_if>
      
      <do_else>
        <!-- Proceed with removal. -->
        <remove_value name="Globals.$key_cue_registry.{$key}.{$cue_index}" />
        <debug_text text="'LIB_Key_Capture.Unregister_Key: Removed cue %s from key %s.'.[$cue.name, $key]" chance="Globals.$DebugChance" filter="general"/>
        
        <!-- If the key's cue list is empty, also remove the key itself. -->
        <do_if value="Globals.$key_cue_registry.{$key}.count == 0">
          <remove_value name="Globals.$key_cue_registry.{$key}" />
          <debug_text text="'LIB_Key_Capture.Unregister_Key: No remaining listeners to key %s; removing it.'.[$key]" chance="Globals.$DebugChance" filter="general"/>
          
          <!-- Update the server. If it isn't connected, ignore any error. -->
          <include_actions ref="Register_Keys_With_Server"/>
        </do_if>
      </do_else>      
      
    </actions>    
  </cue>      
      
    
  <!-- Lib function to update the server list of registered keys. -->
  <library name="Register_Keys_With_Server">
    <actions>
      <!-- TODO: Suppress if not connected to server, to reduce log errors. -->
      <!--Start by merging the keys together, semicolon separated. 
          TODO: is there a natural way to get list of strings -> string?
      -->
      <set_value name="$joined_keys" exact="''" />
      <!-- TODO: why is this giving a property lookup error on key_cue_registry. -->
      <do_all exact="Globals.$key_cue_registry.keys.count" counter="$i">
        <set_value name="$joined_keys" exact="$joined_keys + Globals.$key_cue_registry.keys.list.{$i} + ';'"/>
      </do_all>
      <!--Announce to the server which keys to listen for. 
          Don't worry about callback/error; Read will detect a bad pipe. -->
      <signal_cue_instantly cue="md.LIB_Named_Pipes.Write" param="table[$pipe = 'x4_keys', $msg = 'setkeys:'+$joined_keys ]"/>
    </actions>
  </library>


  <!--
    Lib function to start up the ping/read loop, if it isn't active.
  -->
  <library name="Activate_Read_Loop">
    <actions>
      <!--If the ping/read loops have no pending callback activity,
          kick off a ping. -->
      <do_if value="Globals.$server_access_loop_active == 0">
        <!--Set the loop_active flag early; x4 signal_cue_instantly appears 
            not to be instant enough to prevent this cue from being called 
            again before Ping_Server sets the flag on its own. -->
        <set_value name="Globals.$server_access_loop_active" exact="1"/>
        <signal_cue_instantly cue="Ping_Server"/>
      </do_if>
    </actions>    
    <cues>
    </cues>
  </library>
  
  
  <!-- TODO: maybe move this ping routine to the named pipe api which calls back on success. -->
  <!-- Ping the server to see if it is available. -->
  <cue name="Ping_Server" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!--Flag that the server is being accessed. 
          This will remain 1 until the Ping_Callback or Read_Callback loop
          exits. -->
      <set_value name="Globals.$server_access_loop_active" exact="1"/>
      <signal_cue_instantly cue="md.LIB_Named_Pipes.Write" param="table[$pipe='x4_keys', $msg='ping', $cue=Ping_Callback]"/>
    </actions>
  </cue>
  
  
  <!-- Check if ping write went through. -->
  <cue name="Ping_Callback" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>      
    
      <!-- If an error then the server isn't set up, so wait to ping again. -->
      <!-- TODO: handle cancellations differently. -->
      <do_if value="event.param == 'ERROR' or event.param == 'CANCELLED'">
        <!-- Only keep looping if keys are still registered. -->
        <do_if value="Globals.$key_cue_registry.keys.count != 0">
          <!-- Restart pinging routine, after some delay. -->
          <signal_cue_instantly cue="Ping_Server_After_Delay"/>
        </do_if>
        <do_else>
          <!-- Flag that the server is no longer being accessed. -->
          <set_value name="Globals.$server_access_loop_active" exact="0"/>
        </do_else>
      </do_if>
      
      <do_else>
        <!-- Connected; continue with startup. -->
        <!-- Start by getting the server set up to listen to wanted keys. -->
        <include_actions ref="Register_Keys_With_Server"/>
                
        <!-- Can kick off a first read right away. -->
        <signal_cue_instantly cue="Read_Key"/>
      </do_else>
    </actions>
  </cue>
  
  
  <!--Trigger ping after long delay.
      Should be used by the ping loop to reduce ping overhead. -->
  <cue name="Ping_Server_After_Delay" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <delay exact="10s"/>
    <actions>
      <signal_cue_instantly cue="Ping_Server"/>          
    </actions>
  </cue>
      
    
    
  <!--Read a key. 
      Read_Key and Read_Callback will effectively loop on each other until
      an error occurs.
  -->
  <cue name="Read_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Timeout is used to occasionally check if the loop should stop.
          Alternatively, could give 24h for timeout and just not use it,
          relying on an eventual error, but this might have a slight perf
          impact when no keys are registered but the server is connected,
          since the lua Read function will keep running every cycle.
      -->
      <signal_cue_instantly cue="md.LIB_Named_Pipes.Read" param="table[$pipe='x4_keys', $cue=Read_Callback, $to='1s']"/>
    </actions>
  </cue>
  
  
  <!--Handle the read key.
      If succesful, triggers Read_Key and Ack_Key.
      If error, Resets.
  -->
  <cue name="Read_Callback" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
    
      <!-- If error/cancelled, assume the server shut down. -->
      <do_if value="event.param == 'ERROR' or event.param == 'CANCELLED'">
        <!-- Restart pinging routine. -->
        <signal_cue_instantly cue="Ping_Server"/>
      </do_if>
      
      <!-- On timeout, check if the loop should stop. -->
      <do_elseif value="event.param == 'TIMEOUT'">
        <!-- Only keep looping if keys are still registered. -->
        <do_if value="Globals.$key_cue_registry.keys.count != 0">
          <signal_cue_instantly cue="Read_Key"/>
        </do_if>
        <do_else>
          <!-- Flag that the server is no longer being accessed. -->
          <set_value name="Globals.$server_access_loop_active" exact="0"/>
        </do_else>
      </do_elseif>
      
      
      <do_else>
        <!-- Read succeeded with at least one key. -->
        <!-- Handle callback cues. -->
        <!-- TODO: support multiple keys returned, with some separator. -->
                
        <!-- Start by prefixing the key combo with a '$' for table lookups. -->
        <set_value name="$key" exact="'$' + event.param"/>
        <debug_text text="'LIB_Key_Capture.Read_Callback: received key %s.'.[$key]" chance="Globals.$DebugChance" filter="general"/>
      
        <!-- Is the key returned actually registered? -->
        <do_if value="Globals.$key_cue_registry.{$key}?">
        
          <!-- Convenience renaming. -->
          <set_value name="$cue_list" exact="Globals.$key_cue_registry.{$key}"/>
          
          <!-- Loop over the callback cues. -->
          <do_all exact="$cue_list.count" counter="$i">            
            <!-- TODO: Verify the callback cue still exists. -->
            <!-- Call the cue, with this key combo (without $). -->
            <signal_cue_instantly cue="$cue_list.{$i}" param="event.param"/>              
          </do_all>
                    
        </do_if>
        
        <do_else>
          <!-- Key not registered. TODO: error message. -->
        </do_else>
        
        <!--Acknowledge this key was read.
            Note: this will not bother to check for errors. If the pipe dies,
            a read will fail and catch it. -->
        <signal_cue_instantly cue="md.LIB_Named_Pipes.Write" param="table[$pipe='x4_keys', $msg='ack']"/>
        
        <!-- Request the next key to be read, looping. -->
        <signal_cue cue="Read_Key"/>
        
      </do_else> <!-- End handling of callback cues. -->      
    </actions>
  </cue>
    
</cues>

</mdscript>