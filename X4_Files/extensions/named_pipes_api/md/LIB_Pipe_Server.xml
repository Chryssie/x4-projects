<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="LIB_Pipe_Server" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">

<!--
MD API for interfacing with an external Python based pipe server.
Builds on top of the Named Pipes API.

Goals:
  - Connect to the running python host server process.
  - Allows user to specify the relative path to a python server plugin.
  - Extract the absolute path of x4 and transmit it to the server, for
    the currently running x4 installation (assume multiple on a computer).
  - Transmit user file paths to the host server, to be dynamically imported
    and started.
  - Detect host server errors, and re-announce user files upon
    reconnection.
    
Operation notes:
  - Requires the Python host server be set up and started. This is done by
    the player outside of the game, though can be started before or after
    x4.
  - Pings the server pipe until getting a connection.
  - Failed pings will wait some time before the next ping.
  - Transfers the lua package.paths to the server, where python code parses
    out the x4 absolute path. (Should be adaptable to multiple x4 installations
    without requiring extra player setup.)
  - Reloads on any error, as well as on game or ui reloads.
  - When reloading, signals the Reloaded cue, telling users to register
    their server plugin paths.
  - Passively reads the host server, watching for disconnect errors.
  
Usage:
  
  Use this cue template to register the path to a server module.
  The cue name can be anything. The <> fields should be customized.
  
    <cue name="Register_Pipe_Server" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.LIB_Pipe_Server.Reloaded" />
      </conditions>
      <actions>
        <signal_cue_instantly 
          cue="md.LIB_Pipe_Server.Register" 
          param="'extensions/<mod_folder_name>/<python file>.py'"/>
      </actions>
    </cue>
    
  Write the corresponding python server module. This requires a "main"
  function to act as the entry point, and should preferably import
  the Pipe_Server class from X4_Python_Pipe_Server.
  
  Simple example, echo messages sent from x4 back to it:
  
    from X4_Python_Pipe_Server import Pipe_Server
    def main():
        pipe = Pipe_Server('x4_echo')
        while 1:
            message = pipe.Read()
            pipe.Write(message)
        return
    
    
    
Notes on server access looping cues:

  The cues for accessing the server, either pinging or reading, form
  oscillating loops.  A ping that fails in the callback will re-ping,
  and a read that succeeds or times out will re-read (for the next message).
  Stopping oscillating loops upon reset (game or ui reload) is non-trivial
  to do in a robust, bug-resistant way.
  
  If the cues are made static, they require reset_cue to reuse.  However, this
  command appears to only take effect at the end of a game frame, and hence
  all attempts to re-call a cue that was reset earlier in the same frame
  will fail.  Same-frame recall is a common case, so all experiments with
  resetting static cues were dead ends.
  
  If the cues are instantiated, they can be recalled in the same frame, but
  there is a danger of multiple instances being active, which is not
  wanted.  While the general design of this api would try to avoid such
  multi-instance problems, bugs are always possible.
  
  The current design packs all oscillating cues in a parent Server_Access_Loop
  cue.  When signalled, this cue will record its instance into a global
  variable, and a condition will prevent a new instance starting if the
  prior one is still active.  Internally, a conditionless cue is used to
  start the pinging loop.  When the api reloads (such as on a pipe disconnect
  event), an internal cue will cancel the instance of Server_Access_Loop,
  such that a new instance can be started.
-->
<cues>

  
  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Some globals reset each time the game is loaded or ui reloaded,
    to enable easy changing of constants.
    
    Attributes:
    * registered_modules
      - List of strings, paths to python server modules registered by users.
      - Cleared on reloads.
    * server_access_loop_cue
      - Cue or null, the currently active Server_Access_Loop cue instance.
      - Starts as null. If an active instance dies, calls "exists" on this
        will return false.
    * server_connected
      - Flag, 1 when the server has been pinged succesfully and appears to
        have a valid connection. 0 before connection is set up, or after
        an error/disconnect. Used to suppress some writes before a
        connection is made, though shouldn't be critical to functionality.
    * pipe_name
      - Default name of the pipe used to communicate with the python host.
      - Using "x4_python_host"
    * DebugChance
      - 0 or 100.
  -->  
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
  </cue>
  
  <library name="Reset_Globals">
    <actions>
      <!-- Empty list of server paths. -->
      <set_value name="Globals.$registered_modules" exact="[]"/>
      <!-- Name of the pipe. -->
      <set_value name="Globals.$pipe_name" exact="'x4_python_host'" />
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="100" />
      <!-- Assume no access loop active; any old one should self-kill. -->
      <set_value name="Globals.$server_access_loop_cue" exact="null"/>
      <!-- Server is never connected at reset. -->
      <set_value name="Globals.$server_connected" exact="0"/>
    </actions>
  </library>

  <!--
    Handle game creation, reload, or ui reload, as well as server pipe
    disconnection.
    Goal is to reset some global vars, and signal to users that they
    should re-register their server modules.
    In practice, this is best handled by listening to a signal from
    the named pipe api, to ensure that has reloaded first.
  -->
  <cue name="Reset_On_Lua_Reload" instantiate="true">
    <conditions>
      <check_any>
        <event_cue_signalled cue="md.LIB_Named_Pipes.Reloaded" />
        <event_ui_triggered screen="'Named_Pipes_Api'" control="'%s_disconnected'.[Globals.$pipe_name]" />
      </check_any>
    </conditions>
    <actions>
      <!-- Make sure the global registry is reset. -->
      <include_actions ref="Reset_Globals"/>
      <!-- Send a signal that all users listen to. -->
      <signal_cue_instantly cue="Reloaded"/>
      
      <debug_text text="'reload triggered.'" chance="Globals.$DebugChance" filter="general"/>
    </actions>
  </cue>
  
  
  <!--
    Dummy cue used for signalling.
    When the api wants users to register their servers, it will signal
    this cue. Users can then listen to this cue being signalled.
    This is also used to kill off an older server access loop.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>
    
  
  <!--
    User function to register a python server module.
    This should be resent each time Reloaded is signalled.
    
    Param:
      String, relative path to the python file from the x4 base dir.
      Use forward slashes between folders.
    
    Usage example:
    
      <cue name="Register_Pipe_Server" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.LIB_Pipe_Server.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.LIB_Pipe_Server.Register_Module" 
            param="'extensions/key_capture_api/Send_Keys.py'"/>
        </actions>
      </cue>
  -->
  <cue name="Register_Module" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <set_value name="$path" exact="event.param"/>
      
      <!-- Check if this path is not yet known. -->
      <do_if value="Globals.$registered_modules.indexof.{$path} == 0">
        <!-- Add to the list. -->
        <append_to_list name="Globals.$registered_modules" exact="$path" />
        <debug_text text="'registered server path: %s.'.[$path]" chance="Globals.$DebugChance" filter="general"/>
        
        <!-- Update the server. If it isn't connected, ignore any error. -->
        <include_actions ref="Register_Modules_With_Server"/>
        
        <!-- Make sure the read loop is started, if it wasn't already. -->
        <signal_cue cue="Server_Access_Loop" />
        
      </do_if>
    </actions>    
  </cue>
  
      
    
  <!-- Lib function to update the server list of registered modules. -->
  <library name="Register_Modules_With_Server">
    <actions>
      <!-- Suppress if not connected to server, to reduce log confusion. -->
      <do_if value="Globals.$server_connected == 1">
      
        <!-- Start by merging the entries together, semicolon separated. -->
        <set_value name="$joined_modules" exact="''" />
        <do_all exact="Globals.$registered_modules.count" counter="$i">
          <set_value name="$joined_modules" exact="$joined_modules + Globals.$registered_modules.{$i} + ';'"/>
        </do_all>
        
        <!-- Send this to the server. -->
        <signal_cue_instantly cue="md.LIB_Named_Pipes.Write" param="table[$pipe = Globals.$pipe_name, $msg = 'modules:'+$joined_modules ]"/>
        
      </do_if>
    </actions>
  </library>
  
  
  <!--
    Parent cue for the subcues that access a server, pinging and reading.
    Subcues will form oscillating loops.
    This will cancel its instance when a reload occurs.
    This will not start if a prior instance still exists, as stored
    in Globals.$server_access_loop_cue.
    Instanced, so this can be cancelled and recalled in the same frame.
  -->
  <cue name="Server_Access_Loop" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
      <check_value value="not Globals.$server_access_loop_cue.exists"/>
    </conditions>
    <actions>
      <set_value name="Globals.$server_access_loop_cue" exact="this"/>      
    </actions>
    
    <cues>
    
      <!-- Dummy cue, no conditions, calls Ping_Server right away. -->
      <cue name="Init_Ping_Server">
        <actions>
          <signal_cue_instantly cue="Ping_Server"/>
        </actions>        
      </cue>
      
      
      <!-- 
        Detect a reload, and kill this access loop instance.
        Since this is not instantiated, it will keep the Server_Access_Loop
        alive until this fires.
      -->
      <cue name="Reload_Listener">
        <conditions>
          <event_cue_signalled cue="Reloaded" />
        </conditions>
        <actions>
          <!-- Do not reset flags; they are handled by generic reload code. -->
          <!-- Cancel the namespace, which is the instanced parent 
              (not the static parent). -->
          <cancel_cue cue="namespace"/>
        </actions>        
      </cue>
  
      
      <!-- 
        Lib function for cancelling the parent cue and resetting some state.
        Use this to end the Server_Access_Loop when no modules are registered.
      -->
      <library name="Cancel_Server_Access_Loop">
        <actions>
          <!-- Clear any necessary flags. -->
          <set_value name="Globals.$server_connected" exact="0"/>
          <!-- Cancel the namespace, which is the instanced parent 
              (not the static parent). -->
          <cancel_cue cue="namespace"/>
        </actions>
      </library>
      
  
      <!-- Ping the server to see if it is available. -->
      <cue name="Ping_Server" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <actions>
          <signal_cue_instantly cue="md.LIB_Named_Pipes.Write" param="table[$pipe=Globals.$pipe_name, $msg='ping', $cue=Ping_Callback]"/>
        </actions>
      </cue>
      
      
      <!-- Check if ping write went through. -->
      <cue name="Ping_Callback" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <actions>      
        
          <!-- 
            If an error then the server isn't set up, so wait to ping again.
            Note: if the server was never connected to, lua will not send
            a disconnect signal, and so the Reloaded cue will not have
            been activated.
          -->
          <do_if value="event.param == 'ERROR'">
          
            <!-- Only keep looping if modules are still registered. -->
            <do_if value="Globals.$registered_modules.count != 0">
              <!-- Restart pinging routine, after some delay. -->
              <signal_cue_instantly cue="Ping_Server_After_Delay"/>
            </do_if>
            
            <do_else>
              <!-- Kill the parent cue; no need to connect without servers to host. -->
              <include_actions ref="Cancel_Server_Access_Loop"/>
            </do_else>
          </do_if>
          
          <!-- On a game reload, this comes back as cancelled; don't loop. -->
          <do_elseif value="event.param == 'CANCELLED'">
            <!-- The parent cue is getting killed by other logic, so do nothing. -->
          </do_elseif>
          
          <do_else>
            <!-- Connected; continue with startup. -->
            <set_value name="Globals.$server_connected" exact="1"/>
            
            <!--Send the lua side package.path string to the server, 
                containing the path to this x4 installation. -->
            <signal_cue_instantly cue="md.LIB_Named_Pipes.Write_Special" param="table[$pipe = Globals.$pipe_name, $msg = 'package.path' ]"/>
            
            <!-- Announce the modules to start up. -->
            <include_actions ref="Register_Modules_With_Server"/>
                    
            <!-- Can kick off a first read right away. -->
            <signal_cue_instantly cue="Read_Message"/>
          </do_else>
        </actions>
      </cue>
      
      
      <!--
        Trigger ping after long delay.
        Should be used by the ping loop to reduce ping overhead.
        TODO: shorter delay version for the first couple pings, backing off to a longer version if they are failing.
        TODO: Perhaps use checktime for this instead of delay.
      -->
      <cue name="Ping_Server_After_Delay">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <delay exact="10s"/>
        <actions>
          <signal_cue_instantly cue="Ping_Server"/>
          <reset_cue cue="this"/>
        </actions>
      </cue>
          
        
      <!--Send a read request, wait for timeout or error or message.
          Used to detect when the server host disconnects.
          
          TODO: maybe a lua level option to reduce how often the pipe reads are attempted; every frame is probably unnecessary (though perhaps has no noticeable overhead).
      -->
      <cue name="Read_Message" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <actions>
          <!-- Timeout is used to occasionally check if the loop should stop. -->
          <signal_cue_instantly cue="md.LIB_Named_Pipes.Read" param="table[$pipe=Globals.$pipe_name, $cue=Read_Callback, $to='1s']"/>
        </actions>
      </cue>
      
      
      <!--Handle the read message.
          On error, resets.
          On timeout, loops to another read.
          Currently not expecting control messages, but they may be added
          in the future.
          
          Note: the lua api will raise a disconnect signal if it sees the
          host server disconnect, which triggers Reloaded and hence cancels
          this Server_Access_Loop.  On a game reload, the lua is reset and
          cannot send this signal, but Reloaded triggers anyway in this
          case, again killing this cue.
          As such, this cue doesn't need to handle errors,
          but will be set up to do so for redundancy in case of bugs.
      -->
      <cue name="Read_Callback" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        
        <actions>
        
          <!-- If error, assume the server shut down. -->
          <do_if value="event.param == 'ERROR'">            
            <!-- Lua should have signalled the disconnect, killing this cue by other logic, but be safe here. -->
            <debug_text text="'pipe error; restarting Ping_Server'" chance="Globals.$DebugChance" filter="general"/>
            <!-- Note that the pipe disconnected. -->
            <set_value name="Globals.$server_connected" exact="0"/>
            <!-- Restart pinging routine. -->
            <signal_cue_instantly cue="Ping_Server"/>
          </do_if>
          
          <!-- On a game reload, this comes back as cancelled; don't loop. -->
          <do_elseif value="event.param == 'CANCELLED'">
            <!-- The parent cue is getting killed by other logic, so do nothing. -->
          </do_elseif>
          
          <!-- On timeout, check if the loop should stop. -->
          <do_elseif value="event.param == 'TIMEOUT'">
          
            <!-- Only keep looping if modules are still registered. -->
            <do_if value="Globals.$registered_modules.count != 0">
              <signal_cue_instantly cue="Read_Message"/>
            </do_if>
            
            <do_else>
              <!-- Kill the parent cue; no need to connect without servers to host. -->
              <include_actions ref="Cancel_Server_Access_Loop"/>
            </do_else>
          </do_elseif>
                
          <do_else>
            <!-- Read succeeded with some message. -->
            <!-- Nothing expected for now. -->
            <debug_text text="'received mesage: %s.'.[event.param]" chance="Globals.$DebugChance" filter="general"/>
            <!-- Request the next key to be read, looping. -->
            <signal_cue cue="Read_Key"/>        
          </do_else>    
        </actions>
      </cue>
      
    </cues>
  </cue> <!-- end Server_Access_Loop -->
  
</cues>

</mdscript>