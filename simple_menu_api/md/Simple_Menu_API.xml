<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

<!--@doc-title Simple Menu API -->
<!--@doc-overview
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

After creation, widgets may be partially updated at any time. This is
detailed in the Update_Widget cue.    

Note: raise_lua_event only supports passing strings, numbers, or components.
This api will pass complex tables of args using a blackboard var:
  player.entity.$simple_menu_args
  
-->
  
  
<!--@doc-section
### Widget arguments and properties overview
    
Many of the following cues share some common arguments or arg data types, 
described here. Note: many of these can be replaced with a constant looked
up in the egosoft api backend Helper module. Possible options are included
at the end of this documentation.
    
API args (all widgets)
  * col
    - Integer, column of the row to place the widget in.
    - Uses 1-based indexing.
    - Note: row columns may not always align with table columns:
      - This actually sets the widget as the Nth cell of the row,
      - Row column alignment with the table columns depends on the sizes of
        all prior row cells (as possibly adjusted by colSpan).
      - Eg. if the widget in col=1 had a colSpan=2, then a new col=2
        widget will align with table column 3.
    - Required for now.
  * colSpan = 1
    - Int, how many columns the widget will span.
  * id = none
    - String, unique identifier for the widget.
    - Optional, but needed for Update_Widget calls.
  * echo = none
    - May be any data type.
    - This is returned in the table sent to signalled callback cues,
      for user convenience.
    
Widget properties (all widgets)
  * scaling = true
    - Bool, coordinates and dimensions will be scaled by the ui scaling factor.
  * width, height = 0
    - Ints, widget dimension overrides.
  * x, y = 0
    - Ints, placement offsets.
  * mouseOverText = ""
    - String, text to display on mouseover.
        
Cell properties (all widgets)
  * cellBGColor = Helper.defaultSimpleBackgroundColor
    - Color, cell background color.
  * uiTriggerID = none
    - String, if present then this is the control field for ui
      triggered events on widget activations.
    - Ignore for now; api handles callback cues directly.
        
Events (depends on widget)
  * on<___> (onClick, onTextChanged, etc.)
    - Optional callback cue.
    - When the player interacts with most widgets, ui events will occur.
      On such events, a provided cue will be called with the event results.
    - All event.param tables will include these fields:
      * row, col
        - Longfloat, coordinate of the activated widget.
        - Primarily for use by this backend.
      * id
        - String id given to the widget at creation, or null.
      * event
        - String, name of the event, matching the arg name.
        - Eg. "onClick".
      * echo
        - Same as the "echo" arg provided to widget creation.
    - Extra contents of the event.param are described per widget below.
        
Misc properties (depends on widget):
  * font
    - String, font to use.
    - Typical options: 
      - "Zekton"
      - "Zekton bold"
      - "Zekton fixed"
      - "Zekton bold fixed"
      - "Zekton outlined"
      - "Zekton bold outlined"
  * fontsize
    - Int, typically in the 9 to 12 range.
  * halign
    - String, text alignment, one of ["left", "center", "right"].
  * minRowHeight
    - Int, minimal row height, including y offset.
        
Complex properties:
  * Color
    - Table of ["r", "g", "b", "a"] integer values in the 0-255 range.
  * TextProperty
    - Table describing a text field.
    - Note: in some widgets "text" is a string, others "text" is
      a TextProperty table.
    - Fields:
      * text = ""
      * halign = Helper.standardHalignment
      * x = 0
      * y = 0
      * color = Helper.standardColor
      * font = Helper.standardFont
      * fontsize = Helper.standardFontSize
      * scaling = true
  * IconProperty
    - Table describing an icon.
    - Fields:
      * icon = ""
        - Icon name
        - See libraries/icons.xml for options.
      * swapicon = ""
      * width = 0
      * height = 0
      * x = 0
      * y = 0
      * color = Helper.standardColor
      * scaling = true
  * HotkeyProperty
    - Table describing an activation hotkey.
    - See libraries/contexts.xml for potential options.
    - Note: hotkeys have not yet worked in testing.
    - Fields:
      * hotkey = ""
        - String, the hotkey action, matching a valid INPUT_STATE.
      * displayIcon = false
        - Bool, if the widget displays the associated icon as a hotkey.
      * x = 0
      * y = 0
        - Offsets of the icon if displayIcon is true.
  * StandardButtonProperty
    - Table specifying which menu level buttons to include.
    - Fields:
      * close = true
      * back = true
      * minimize = false
-->


<cues>

  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.simple_menu_api.lua.Interface'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * row
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * menu_properties
      - Table holding the menu creation args of the most recent menu.
    * widget_properties
      - Table of tables of properties provided by the user for widgets, 
        annotated with additional information (eg. row number).
      - Holds shallow copies of the user args tables.
      - Outer table keyed by widget row, inner table by widget column.
      - Outer table may also be keyed by widget id, when the user provides
        an id string; in such cases the widget properties table will be
        recorded twice (by id and row/col).
      - Locally used for the callback cue storage, with echoing behavior
        intended to aid the user in handling callbacks.
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu.
      
    Additionally, complex data will be sent to lua using a blackboard var:
    * player.entity.$simple_menu_args
      - List of tables (or none), args sent with lua commands.
      - The list is appended to here, copied and deleted in lua.
      - The list is used to account for (common) cases where multiple commands
        are sent in the same frame, since the lua will only process them late
        in the frame, requiring arg buffering.
      - Since lua cannot edit the list directly, and cannot replace it with
        a modified list, it will just delete this var after reading it.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Named_Pipes'" control="'reloaded'" />
        </conditions>
        <actions>
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="100" />
      <set_value name="Globals.$widget_properties" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />
      <set_value name="Globals.$menu_properties" exact="table[]" />
      <!-- Reset the blackboard list, to clear old junk. TODO: delete. -->
      <set_value name="player.entity.$simple_menu_args" exact="[]" />
    </actions>
  </library>

  <!--
    Library function which will reset before opening a new menu.
    Clears out state from the prior menu.
  -->
  <library name="Reset_Menu">
    <actions>
      <set_value name="Globals.$widget_properties" exact="table[]" />
      <set_value name="Globals.$row" exact="0" />
      <set_value name="Globals.$menu_properties" exact="table[]" />
      <set_value name="player.entity.$simple_menu_args" exact="[]" />
    </actions>
  </library>

  
  <!--@doc-cue
    Dummy cue used for signalling that the game or ui was reloaded.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!-- 
    Small helper function which will replace $args with an empty
    table if it is null.
    -->
  <library name="Init_Args_Table">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
    </actions>
  </library>
  
  <!-- 
    Lib helper for fill in default widget args.
    The args table should be in $args.
    Will automatically include a check for null args and init the table,
    so a call to Init_Args_Table isn't needed.
    TODO: remove cloning; Send_Command will do that.
  -->
  <library name="Fill_Widget_Default_Args">
    <actions>
      <include_actions ref="Init_Args_Table"/>
      <!-- Currently just set col to 1 by default. -->
      <do_if value="not $args.$col?">
        <set_value name="$args.$col" exact="1" />
      </do_if>
    </actions>
  </library>
  
  <!-- 
    Helper lib to send a command to lua, using a blackboard var for arg transfer.
    Adds a table of args to the player.entity '$simple_menu_args' list,
    creating it if it doesn't exist, so that lua can access it.
    
    Input table should be in $args.    
    -->
  <library name="Lib_Send_Command">
    <actions>
    </actions>
  </library>

  
  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Generic Command Cue
    -->
  
  <!-- Note: assume any users may call Send_Command directly, so do all special
  command handling here. -->
  <!--@doc-cue
    Generic cue for sending commands to lua. Other api cues redirect here
    to interface with the lua backend. Users may utilize this cue if they
    find it more convenient. See other cues for arg descriptions.
    
    Param: Table with the following items:
    * command
      - String, the command to send.
      - Supported commands:
        - Register_Options_Menu
        - Create_Menu
        - Close_Menu
        - Display_Menu
        - Add_Submenu_Link
        - Add_Row
        - Make_Widget
        - Update_Widget
    * ...
      - Any args requied for the command.
      - Note: Make_Widget commands require a $type string to specify the
        widget type (found quoted in per-widget descriptions).
    -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- If the param is null, something went wrong in the call. TODO -->
      
      <!-- 
        Use a shallow copy for this, to avoid errors if the user reuses tables.
        This may be needed even if user reuses the table to make the same 
        widget on next menu opening, since this code might get confused
        by eg. auto $row inclusion below.
      -->
      <set_value name="$args" exact="event.param.clone" />
            
      <!-- The following command handlers are ordered most to least common. -->
      
      <!-- Handle widget arg recording. -->
      <do_if value="$args.$command == 'Make_Widget'">
        <!-- TODO: verify a $type was provided. -->
        
        <!-- Store the row in the args, for possible later lookup. -->
        <!-- TODO: support rows being specified ahead of time. -->
        <set_value name="$args.$row" exact="Globals.$row" />
        
        <!-- Set any widget default args. Just col for now. -->
        <do_if value="not $args.$col?">
          <set_value name="$args.$col" exact="1" />
        </do_if>
        
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <set_value name="Globals.$widget_properties.{Globals.$row}.{$args.$col}" exact="$args" />
        <debug_text text="'Recorded args for row,col: (%s,%s)'.[Globals.$row, $args.$col]"
                  chance="Globals.$DebugChance" filter="general"/>
        
        <!-- Also record by user id, if available. -->
        <do_if value="$args.$id?">
          <set_value name="Globals.$widget_properties.{'$'+ $args.$id}" exact="$args" />
        </do_if>
      </do_if>
            
      <!-- Inc row counter. -->
      <do_elseif value="$args.$command == 'Add_Row'">
        <!-- 
          Update the row count, and expand the callback table.
          Note: since the global $row inits to 0, increment will go first to
          bring the first row up to 1 (1-based indexing).
          -->
        <set_value name="Globals.$row" operation="add" />
        <set_value name="Globals.$widget_properties.{Globals.$row}" exact="table[]" />
      </do_elseif>      
           
      <!-- Handle standalone menu arg recording. TODO: merge in with options menus table. -->
      <do_elseif value="$args.$command == 'Create_Menu'">
        <!-- Reset old state. -->
        <include_actions ref="Reset_Menu"/>      
        <set_value name="Globals.$menu_properties" exact="$args"/>
      </do_elseif>
            
      <!-- Handle options menu arg recording. -->
      <do_elseif value="$args.$command == 'Register_Options_Menu'">
        <!-- Record the args using the menu id, $ prefixed. -->
        <set_value name="Globals.$options_submenu_specs.{'$'+event.param.$id}" exact="$args" />
      </do_elseif>      
      
      <!-- Args are transmitted to lua  using a blackboard var. -->
      <!-- Create the blackboard list if it doesn't exist. -->
      <do_if value="not player.entity.$simple_menu_args?">
        <set_value name="player.entity.$simple_menu_args" exact="[]" />
      </do_if>
      <append_to_list name="player.entity.$simple_menu_args" exact="$args"/>

      <debug_text text="'Sending Process_Command with args: %s'.[$args]"
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'"/>
    </actions>
  </cue>

  
  
  <!-- ################################################################### -->
  <!--                            Menu Setup                               -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Menu Creation Cues
    -->
  
  <!--@doc-cue
    Register an options menu, which will be accessible as a submenu of
    the normal game options.
    
    Param:
      Table with the following items:
      * $id
        - String, unique identifier for this menu.
        - Needs to differ from egosoft menu names, as well as any other
          mod registered menus.
      * $title
        - Text to display in the table header.
      * $columns
        - Integer, total number of columns in the menu table.
      * $cue
        - Cue to be called when the submenu needs to be built.
        - This cue should use addRow and makeX functions to build the menu.
        - Do not call Create_Menu from this cue.
      * $private
        - Int 0 or 1, optional, controls if the menu will be listed automatically
          in the general list of Extension Options menus.
        - Defaults to 0, non-private.
        - Set to private for submenus you will manually link to using
          Add_Submenu_Link.
                
    Call this each time the Reloaded cue is signalled. Example:
    ```xml
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $cue     = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    ```
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Register_Options_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--TODO: frame+table general properties.-->
  <!--TODO: ways to change some defaults, notable text.-->
  <!--@doc-cue
    Create a fresh standalone menu.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Each menu created will internally be given a frame to hold a table
    in which widgets will be placed.  The frame and table properties
    are also set with this cue.
    
    Note: table and frame properties are pending development.
    
    Param:
      Table with the following items:
      * columns
        - Integer, total number of columns in the menu table.
        - Max is 13.
      * title
        - Text to display in the table header.
      * width
        - Int, optional, menu width. Defaults to a predefined width.
      * height
        - Int, optional, menu height. Default expands to fit contents.
      * offsetX
      * offsetY
        - Ints, optional, amount of space between menu and screen edge.
        - Positive values taken from top/left of screen, negative values
          from bottom/right of screen.
        - Defaults will center the menu.
      * onClose
        - Cue, optional, signalled when the menu is closed.
        - The event.param will be "back" or "close" depending on if the
          menu back button was pressed.
      * frame
        - Subtable, properties for the frame, as follows:
        * exclusiveInteractions = false
          - Bool, if interactions (player input) are exclusive to this view.
          - TODO: is those only as compared to other frames?  maybe drop.
        * backgroundID = ""
          - String, name of an icon to use as the background texture.
          - If blank, no background applied.
        * backgroundColor = Helper.color.white
          - Color of the background texture.
        * overlayID = ""
          - String, name of an icon to use as an overlay effect.
        * overlayColor = Helper.color.white
          - Color of the overlay texture.
        * standardButtons = Helper.standardButtons_CloseBack
          - StandardButtonProperty
          - Which standard buttons will be given, eg. back/minimize/close.
          - These are generally placed in the top right.
        * standardButtonX = 0
          - Int, x offset for the buttons.
        * standardButtonY = 0
          - Int, y offset for the buttons.
        * showBrackets = false
          - Bool, if frame brackets will be shown.
        * autoFrameHeight = false
          - Bool, if the frame height will be autocalculated based on contents.
          - TODO: how does this interact with menu height.
        * closeOnUnhandledClick = false
          - Bool, if the menu triggers an onHide even if the player clicks
            outside of its area.
          - Pending development.
        * playerControls = false
          - Bool, if player controls are enabled while the menu is open.
        * startAnimation = true
          - Bool, if a menu start animation is played.
        * enableDefaultInteractions = true
          - Bool, if default inputs are enabled (escape, delete, etc.).
      * table
        - Subtable, properties for the table of widgets, as follows:
        * tabOrder = 1
          - Int, 0 sets table as non-interactive, 1 as interactive.
          - Generally leave as 1 unless it is purely an info display.
        * skipTabChange = false
          - Bool, if tabbing will skip selecting this table's contents.
          - Pending testing.
        * defaultInteractiveObject = false
          - Bool, sets this table as the interactive object of the frame
            by default.
          - TODO: maybe support.
        * borderEnabled = true
          - Bool, if the table cells have a background color.
        * reserveScrollBar = true
          - Bool, if the table width reserves space for a scrollbar.
        * wraparound = false
          - Bool, if arrow key traversal of table cells will wrap around edges.
        * highlightMode = "on"
          - String, controls highlighting behavior of table selections.
          - One of ["on","column","off","grey"]
        * multiSelect = false
          - Bool, whether the table allows selection of multiple cells.
        * backgroundID = ""
          - String, name of an icon to use as the background texture.
        * backgroundColor = Helper.color.white
          - Color of the background texture.
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Create_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--TODO: should closing trigger an onClose event?-->
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Close_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Display the menu.
    Mainly for use with options menus, which requires this to know when
    all build commands are complete.
    -->
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Display_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu.
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * menu_id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Submenu_Link'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  

  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Widget Creation Cues
    -->
  
  
  <!--TODO: make rows selectable or not, set up echo and callbacks for
      RowSelected and similar events.-->
  <!--@doc-cue
    Add a row to the current menu.
    Following widget creation commands add to the most recently added row.
    Max is 130 rows.
    
    Param: Table with the following items.
    * selectable = true
      - Bool, if the row is selectable by the player.
      - Should always be true for rows with interactable widgets.
    * scaling = true
      - Bool, default ui scaling of cells (width/height/coordinates).
      - For now, this is expected to be overridden by per-widget settings.
    * fixed = false
      - Bool, fixes the row in place so it cannot be scrolled.
      - Requires prior rows also be fixed.
    * borderBelow = true
      - Shows a border gap before the next row, if present.
    * bgColor = Helper.defaultSimpleBackgroundColor
      - Color, background of the row.
      - Sets default color of cells.
    * multiSelected = false
      - Bool, row is preselected for multiselect menu tables.
  },
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Row'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--TODO: rendertarget (placeholder sizing widget)-->
  
  <!--@doc-cue
    Make a "text" cell for displaying non-interactive text.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * titleColor
      - If given, puts the widget in title mode.
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    
    
    Hint: egosoft menus make horizontal gaps using wide, empty text cells.
    Example, assuming 2 table columns:
    ```xml      
      <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"
                            param ="table[$selectable = false]"/>
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Make_Text"
        param = "table[
          $col = 1, 
          $colSpan = 2,
          $height = 'Helper.borderSize',
          $fontsize = 1,
          $cellBGColor = 'Helper.color.transparent60',
          ]"/>
    ```
    -->
  <cue name="Make_Text" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'text'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "boxtext" cell.  Similar to text, but with an outlining box.
    Note: the outline box highlighting can behave oddly as the player
    interacts with other widgets.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * boxColor
      - Color of the surrounding box.
      - Updateable
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    -->
  <cue name="Make_BoxText" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'boxtext'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "button" cell.
    Adds to the most recent row.
    
    Param: Table with the following items.
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties   
    * onClick
      - Cue to callback when the button is left clicked.
    * onRightClick
      - Cue to callback when the button is right clicked.
    * text
      - TextProperty.
      - Updateable text and color
    * text2
      - TextProperty.
      - Updateable text and color
    * active = true
      - Bool, if the button is active.
      - Updateable
    * bgColor = Helper.defaultButtonBackgroundColor
      - Color of background.
      - Updateable
    * highlightColor = Helper.defaultButtonHighlightColor
      - Color when highlighted.
      - Updateable
    * icon
      - IconProperty
    * icon2
      - IconProperty
    * hotkey
      - HotkeyProperty
      
      
    onClick event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'button'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make an "editbox" cell, for text entry.
    Adds to the most recent row.
    
    Warning: due to a (likely) typo bug, x4 is limited to 5 text edit boxes
    in a single menu.
    If many edit fields are needed, consider using sliders for numeric values
    (limit 50), where users can click the slider displayed value to use it
    like an editbox.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onTextChanged
      - Cue to call when the player changes the box text. 
      - Occurs on every letter change.
    * onEditBoxDeactivated
      - Cue to call when the player deselects the box.
      - Deselection may occur when selecting another element, pressing enter,
        or pressing escape.
      - Does not trigger if the menu is closed.
    * bgColor = Helper.defaultEditBoxBackgroundColor
      - Color of background.
    * closeMenuOnBack = false
      - Bool, if the menu is closed when the 'back' button is pressed while
        the editbox is active.
      - Description unclear.
    * defaultText
      - String, the default text to display when nothing present.
      - Updateable
    * textHidden = false
      - Bool, if the text is invisible.
    * encrypted = false
      - Bool, if the input has an encrypted style of display.
    * text
      - TextProperty
    * hotkey
      - HotkeyProperty
      
      
    onTextChanged event returns:
    * row, col, echo, event, id
    * text
      - String, the new text in the box.
        
    onEditBoxDeactivated event returns:
    * row, col, echo, event, id
    * text
      - String, the current text in the box.
    * textchanged
      - Bool, if the text was changed since being activated.
    * wasconfirmed
      - Bool, false if the player pressed "escape", else true.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'editbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a horizontal "slidercell" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onSliderCellChanged
      - Cue to call when the slider value is changed.
      - When the player drags the slider around, this will be called
        repeatedly at intermediate points.
      - When the player types into the editbox, this will trigger on
        every typed character.
    * onSliderCellActivated
      - Cue to call when the player activates the slider.
    * onSliderCellConfirm
      - Cue to call when the player deactivates the slider.
      - Triggers less often than onSliderCellChanged.
      - Recommended to use this over other events.
    * bgColor = Helper.defaultSliderCellBackgroundColor
      - Color of background.
    * valueColor = Helper.defaultSliderCellValueColor
      - Color of value.
    * posValueColor = Helper.defaultSliderCellPositiveValueColor
      - Color, positive value if fromCenter is true
    * negValueColor = Helper.defaultSliderCellNegativeValueColor
      - Color, negative value if fromCenter is true
    * min = 0
      - Min value the bar is sized for
    * max = 0
      - Max value the bar is sized for
      - Updateable
    * minSelect = none
      - Min value the player may select.
      - Defaults to min
      - Do not use maxSelect if exceedMaxValue is true
    * maxSelect
      - Max value the player may select.
      - Defaults to max
      - Updateable
    * start = 0
      - Initial value
    * step = 1
      - Step size between slider points
    * suffix = ""
      - String, suffix on the displayed current value.
    * exceedMaxValue = false
      - Bool, if the player can go over the max value.
      - Requires min >= 0.
    * hideMaxValue = false
      - Bool, hides the max value.
    * rightToLeft = false
      - Bool, enables a right/left mirrored bar.
    * fromCenter = false
      - Bool, bar extends from a zero point in the center.
    * readOnly = false
      - Bool, disallows player changes.
    * useInfiniteValue = false
      - Bool, sets slider to show infinity when infiniteValue is reached.
    * infiniteValue = 0
      - Value at which to show infinity when useInfiniteValue is true.
    * useTimeFormat = false
      - Bool, sets the slider to use a time format.
    * text
      - TextProperty
    
    
    onSliderCellChanged event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
      
    onSliderCellActivated event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    * posx, posy
      - Coordinates of the widget (likely not useful).
      
    onSliderCellConfirm event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
    * valuechanged
      - Bool, true if the value changed since being activated.
      - If the player escapes out of the editbox, this will be false and
        the value will be the pre-edit value.
      
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'slidercell'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "dropdown" selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * options
      - List of tables describing each option.
      - Each subtable has these fields:
        * text = ""
          - String, option text.
        * icon = ""
          - String, icon name.
        * id
          - Optional string or number, identifier of the option.
          - Returned to callbacks to indicate option selected.
          - Defaults to the option's list index (1-based).
        * displayremoveoption = false
          - Bool, if true the option will show an 'x' that the player can
            click to remove it from the dropdown list.
    * onDropDownActivated
      - Cue to call when the player activates the dropdown.
    * onDropDownConfirmed
      - Cue to call when the player selects an option.
    * onDropDownRemoved
      - Cue to call when the player removes an option.
    * startOption = ""
      - String or number, id of the initially selected option.
      - Updateable
    * active = true
     - Bool, if the widget is active.
    * bgColor = Helper.defaultButtonBackgroundColor
     - Color of background.
    * highlightColor = Helper.defaultButtonHighlightColor
     - Color when highlighted.
    * optionColor = Helper.color.black
      - Color of the options.
    * optionWidth, optionHeight = 0
      - Dimensions of the options.
    * allowMouseOverInteraction = false
      - Bool, ?
    * textOverride = ""
      - String, ?
    * text2Override = ""
      - String, ?
    * text
     - TextProperty
    * text2
     - TextProperty
    * icon
     - IconProperty
    * hotkey
     - HotkeyProperty
      
      
    onDropDownActivated event returns:
    * row, col, echo, event, id
        
    onDropDownConfirmed event returns:
    * row, col, echo, event, id
    * id
      - String or number, id of the selected option.
      
    onDropDownRemoved event returns:
    * row, col, echo, event, id
    * id
      - String or number, id of the removed option.
      
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'dropdown'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make an "icon" cell. Note: many icons are large, and may need explicit
    width/height to adjust the sizing.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * icon = ""
      - String, icon id
      - Updateable
    * color = Helper.standardColor
      - Color
      - Updateable
    * text
      - TextProperty
      - Updateable text
    * text2
      - TextProperty
      - Updateable text
    -->
  <cue name="Make_Icon" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'icon'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "checkbox" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onClick
      - Cue to callback when the checkbox is clicked.
    * checked = false
      - Bool or int, if checked initially.
      - Updateable
    * bgColor = Helper.defaultCheckBoxBackgroundColor
     - Color of background.
    * active = true
     - Bool, if the widget is active.
     
    onClick event returns:
    * row, col, echo, event, id
    * checked
      - Int, 0 or 1, checkbox status after click.
      
    -->
  <cue name="Make_CheckBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'checkbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  
  <!--@doc-cue
    Make a "statusbar" cell. This is a bar that have a baseline value,
    is filled based on current value, and coloring is based on if the
    current is greater or less than the baseline.
    Adds to the most recent row.
    
    Pending development.
    
    Param: Table with the following items
    * col, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * current = 0
      - Int, determines fill of the bar.
      - Updateable
    * start = 0
      - Int, baseline value of the bar. Coloring of bar depends on current
        compared to start.
      - Updateable
    * max = 0
      - Int, max value of the bar, used for graphic scaling.
      - Min value of the bar is always pinned at 0.
      - Updateable
    * valueColor = Helper.defaultStatusBarValueColor
      - Color
    * posChangeColor = Helper.defaultStatusBarPosChangeColor
      - Color
    * negChangeColor = Helper.defaultStatusBarNegChangeColor
      - Color
    * markerColor = Helper.defaultStatusBarMarkerColor
      - Color
    -->
  <cue name="Make_StatusBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'statusbar'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  
  <!--@doc-cue
    Update a widget's state after creation.
    
    Param: Table with the following items
    * id
      - String, original id assigned to the widget at creation.
    * ...
      - Any args to be updated, matching the original widget creation args
        layout.
      - Which widget properties can be updated depends on the specific widget.
  -->
  <cue name="Update_Widget" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param" />
      
      <!-- Look up the id in recorded widget properties. -->
      <!-- Skip if there is an id problem. -->
      <do_if value="$args.$id? and Globals.$widget_properties.{'$'+ $args.$id}?">
        <set_value name="$args_table" exact="Globals.$widget_properties.{'$'+ $args.$id}"/>
        
        <!-- Fill in the row/col for the lua to find this widget. -->
        <set_value name="$args.$row" exact="$args_table.$row" />
        <set_value name="$args.$col" exact="$args_table.$col" />
        
        <!-- Set command string. -->
        <set_value name="$args.$command" exact="'Update_Widget'" />
        
        <!-- Send it off. -->
      <signal_cue_instantly cue="Send_Command" param="$args"/>
      </do_if>
      
      <do_else>
        <debug_text text="'Found no widget with id: %s'.[$args.$id]"
                  chance="Globals.$DebugChance" filter="general"/>
      </do_else>

    </actions>
  </cue>
  
  
  <!-- ################################################################### -->
  <!--                             Callbacks                               -->
  <!-- ################################################################### -->
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets. Handle callbacks to user cues.
    
    The callback will echo the original widget args table, annotated with
    the data returned from lua. User code may use this feature to attach
    data to widgets at creation time, and use that echo'd data in
    callback handling.
        
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. This table will always have
    $row and $col of the widget the player modified, along with any
    per-widget state information.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
                
      <!-- Look up the callback cue for this row/col and event. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$args_table" exact="@Globals.$widget_properties.{$response.$row}.{$response.$col}" />
      <set_value name="$cue" exact="@$args_table.{'$' + $response.$event}" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
              
        <!-- Add the $echo to the response, or null. -->
        <set_value name="$response.$echo" exact="@$args_table.$echo" />

        <!-- Add the $id to the response, or null. -->
        <set_value name="$response.$id" exact="@$args_table.$id" />
        
        <signal_cue_instantly cue="$cue" param="$response"/>
      </do_if>
      
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for row,col: (%s,%s)'.[$response.$row, $response.$col]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$options_submenu_specs.{'$'+$id}.$cue" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        
        <!-- Reset old state. -->
        <include_actions ref="Reset_Menu"/>
        
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue"/>
        
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  <!--
    Listen for the lua signal of a closed standalone menu.
    event.param3 is a string, either "back" or "close", depending on
    if a back button was used or not.
  -->
  <cue name="Capture_Lua_Menu_Close" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'onCloseElement'" />
    </conditions>
    
    <actions>
      <!-- Look up the callback cue. -->
      <!-- Use @, so if a cue isn't found this yields null. -->
      <set_value name="$cue" exact="@Globals.$menu_properties.$onClose" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">
        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="event.param3" />
      </do_if>
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu closing.'" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  <!-- ################################################################### -->
  <!--                             Extra Docs                              -->
  <!-- ################################################################### -->
  <!--Note: put these inside cues, due to doc gen parsing top level then cue level.-->

  <!--@doc-section
  #### Helper Consts

  In the egosoft backend, there is a "Helper" module which defines many
  constants used in the standard menus such as colors, fonts, etc.
  Arguments may optionally be given as a string matching a Helper const,
  eg. "Helper.color.brightyellow". A selected list of possibly useful
  helper consts follows.  
  
  * Font related
    - Helper.standardFontBold = "Zekton bold"
    - Helper.standardFontMono = "Zekton fixed"
    - Helper.standardFontBoldMono = "Zekton bold fixed"
    - Helper.standardFontOutlined = "Zekton outlined"
    - Helper.standardFontBoldOutlined = "Zekton bold outlined"
    - Helper.standardFont = "Zekton"
    - Helper.standardFontSize = 9
    - Helper.standardTextOffsetx = 5
    - Helper.standardTextOffsety = 0
    - Helper.standardTextHeight = 16
    - Helper.standardTextWidth = 0
    - Helper.titleFont = "Zekton bold"
    - Helper.titleFontSize = 12
    - Helper.titleOffsetX = 3
    - Helper.titleOffsetY = 2
    - Helper.titleHeight = 20
    - Helper.headerRow1Font = "Zekton bold"
    - Helper.headerRow1FontSize = 10
    - Helper.headerRow1Offsetx = 3
    - Helper.headerRow1Offsety = 2
    - Helper.headerRow1Height = 20
    - Helper.headerRow1Width = 0
  
  * Sizing
    - Helper.standardButtonWidth = 30
    - Helper.standardButtonHeight = 20
    - Helper.standardFlowchartNodeHeight = 30
    - Helper.standardFlowchartConnectorSize = 10
    - Helper.standardHotkeyIconSizex = 19
    - Helper.standardHotkeyIconSizey = 19
    - Helper.subHeaderHeight = 18
    - Helper.largeIconFontSize = 16
    - Helper.largeIconTextHeight = 32
    - Helper.configButtonBorderSize = 2
    - Helper.scrollbarWidth = 19
    - Helper.buttonMinHeight = 23
    - Helper.standardIndentStep = 15
    - Helper.borderSize = 3
    - Helper.slidercellMinHeight = 16
    - Helper.editboxMinHeight = 23
    - Helper.sidebarWidth = 40
    - Helper.frameBorder = 25
    
  * StandardButtonProperty
    - Helper.standardButtons_CloseBack
    - Helper.standardButtons_Close
  
  * Colors
    - Helper.color.black
    - Helper.color.slidervalue
    - Helper.color.green
    - Helper.color.playergreen
    - Helper.color.grey
    - Helper.color.lightgreen
    - Helper.color.lightgrey
    - Helper.color.orange
    - Helper.color.darkorange
    - Helper.color.red
    - Helper.color.semitransparent
    - Helper.color.transparent60
    - Helper.color.transparent
    - Helper.color.white
    - Helper.color.yellow
    - Helper.color.brightyellow
    - Helper.color.warning
    - Helper.color.done
    - Helper.color.available
    - Helper.color.darkgrey
    - Helper.color.mission
    - Helper.color.warningorange
    - Helper.color.blue
    - Helper.color.standardColor
    - Helper.color.statusRed
    - Helper.color.statusOrange
    - Helper.color.statusYellow
    - Helper.color.statusGreen
    - Helper.color.defaultHeaderBackgroundColor
    - Helper.color.defaultSimpleBackgroundColor
    - Helper.color.defaultTitleBackgroundColor
    - Helper.color.defaultArrowRowBackgroundColor
    - Helper.color.defaultUnselectableBackgroundColor
    - Helper.color.defaultUnselectableFontColor
    - Helper.color.defaultButtonBackgroundColor
    - Helper.color.defaultUnselectableButtonBackgroundColor
    - Helper.color.defaultButtonHighlightColor
    - Helper.color.defaultUnselectableButtonHighlightColor
    - Helper.color.defaultCheckBoxBackgroundColor
    - Helper.color.defaultEditBoxBackgroundColor
    - Helper.color.defaultSliderCellBackgroundColor
    - Helper.color.defaultSliderCellValueColor
    - Helper.color.defaultSliderCellPositiveValueColor
    - Helper.color.defaultSliderCellNegativeValueColor
    - Helper.color.defaultStatusBarValueColor
    - Helper.color.defaultStatusBarPosChangeColor
    - Helper.color.defaultStatusBarNegChangeColor
    - Helper.color.defaultStatusBarMarkerColor
    - Helper.color.defaultBoxTextBoxColor
    - Helper.color.defaultFlowchartOutlineColor
    - Helper.color.defaultFlowchartBackgroundColor
    - Helper.color.defaultFlowchartValueColor
    - Helper.color.defaultFlowchartSlider1Color
    - Helper.color.defaultFlowchartDiff1Color
    - Helper.color.defaultFlowchartSlider2Color
    - Helper.color.defaultFlowchartDiff2Color
    - Helper.color.defaultFlowchartConnector1Color
    - Helper.color.defaultFlowchartConnector2Color
    - Helper.color.defaultFlowchartConnector3Color
      
  -->
  <!--TODO: how to support Helper tables of Text cell args.-->

</cues>
  
</mdscript>