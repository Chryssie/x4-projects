<?xml version="1.0" encoding="ISO-8859-1" ?>
<mdscript name="Key_Capture" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xsi:noNamespaceSchemaLocation="md.xsd">

<!--
MD API support for capturing key presses.
This makes use of the Named Pipe API and an external python server.
Python will handle keypress detection, and will transmit to this MD script
which in turn handles callbacks to user specified cues.

Goals:
  - Allow user to register a key with a cue.
  - When key pressed, call the user cue.
  
  
TODO:
  Add an option to suppress further key matching when a key is held down,
  eg. ignore the extra 'press' events sent by the keyboard without a 'release'
  event.
  
-->
<cues>
  
  <!--
    Register the pipe server with the python host.
  -->  
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly 
        cue="md.Pipe_Server_Host.Register_Module" 
        param="'extensions/key_capture_api/Send_Keys.py'"/>
    </actions>
  </cue>
      
      
  <!-- Use the generic server reader library.
      Needs a cue wrapping it, else get property errors on the library refs. -->
  <cue name="Server_Reader_Wrapper">
    <cues>
      <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
        <param name="Actions_On_Init"     value="Actions_On_Init"/>
        <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
        <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
        <param name="Actions_On_Read"     value="Actions_On_Read"/>
      </cue>
    </cues>
  </cue>
  

  <library name="Actions_On_Init">
    <actions>    
      <!--
      - Table, indexed by key descriptor (string), holding lists of cues.
      - Key descriptors have an extra '$' prefixed, due to x4 quirkiness.
      - Normally expect only one cue to be registered per key, but it
        might be higher.
      - Keys with no registered cues should be removed.
      - If table is empty, no keys are being listened to.
      -->
      <set_value name="$key_cue_registry" exact="table[]"/>
      
      <!-- Name of the pipe. -->
      <set_value name="$Pipe_Name" exact="'x4_keys'" />

      <set_value name="$DebugChance" exact="100" />
    </actions>
  </library>
  
  
  <library name="Actions_On_Reload">
    <actions>
      <include_actions ref="$Actions_On_Init"/>
      
      <!-- Send a signal that all users listen to. -->
      <signal_cue_instantly cue="md.Key_Capture.Reloaded"/>
    </actions>
  </library>

  
  <library name="Actions_On_Connect">
    <actions>
      <!-- Announce the wanted keys to the server. -->
      <include_actions ref="md.Key_Capture.Register_Keys_With_Server"/>
    </actions>
  </library>
  
  
  <library name="Actions_On_Read">
    <actions>
      <!-- Read succeeded with at least one key. -->
      <!-- Handle callback cues. -->
      <!-- TODO: support multiple keys returned, with some separator. -->
              
      <!-- Start by prefixing the key combo with a '$' for table lookups. -->
      <set_value name="$key" exact="'$' + event.param"/>
      <debug_text text="'Received key %s.'.[$key]" 
                  chance="$DebugChance" filter="general"/>
    
      <!-- Is the key returned actually registered? -->
      <do_if value="$key_cue_registry.{$key}?">
      
        <!-- Convenience renaming. -->
        <set_value name="$cue_list" exact="$key_cue_registry.{$key}"/>
        
        <!-- Loop over the callback cues. -->
        <do_all exact="$cue_list.count" counter="$i">
          <!-- Verify the cue still exists before calling it. -->
          <do_if value="$cue_list.{$i}.exists">
            <!-- Call the cue, with this key combo (without $). -->
            <signal_cue_instantly cue="$cue_list.{$i}" param="event.param"/>
          </do_if>
          <!-- TODO: remove non-existent cues. -->
        </do_all>
                  
      </do_if>
      
      <do_else>
        <!-- Key not registered. TODO: error message. -->
      </do_else>
      
      <!--Acknowledge this key was read.
          Note: this will not bother to check for errors. If the pipe dies,
          a read will fail and catch it. -->
      <signal_cue_instantly 
        cue="md.Named_Pipes.Write" 
        param="table[$pipe=$Pipe_Name, $msg='ack']"/>
    </actions>
  </library>
  
  
  <!--
    Dummy cue used for signalling.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


      
  <!--
    User function to register a key with a cue.
    If this is the first cue registered, it will start the key listening loop.
    This should be re-sent each time Reloaded is signalled.
    
    Param  : Table with the following items:
      key  : String specifying the key/combo to capture.
             TODO: document key syntax.
      cue  : Callback, the cue to call when the key is pressed.
      
    Returns:
      Callback cue will be given the key pressed in event.param.
    
    Usage example:
    
      <cue name="Register_Keys" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Key_Capture.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Key_Capture.Register_Key" 
            param="table[$key='w', $cue=OnKeyPress]"/>
        </actions>
      </cue>      
  -->
  <cue name="Register_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Adjust the key to prefix with a $ for x4 tables. -->
      <set_value name="$key" exact="'$' + event.param.{'$key'}"/>
      <set_value name="$cue" exact="event.param.{'$cue'}"/>
      
      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Server_Reader.$key_cue_registry.{$key}?">
        <set_value name="Server_Reader.$key_cue_registry.{$key}" exact="[]"/>
      </do_if>
      
      <!-- Check if the cue is already recorded for this key. -->
      <do_if value="Server_Reader.$key_cue_registry.{$key}.indexof.{$cue} != 0">
        <!-- Print some warning. -->
        <debug_text text="'Warning, cue %s already registered to key %s.'.[$cue.name, $key]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
      </do_if>
      <do_else>
        <!-- It isn't recorded, so add it in. -->
        <append_to_list name="Server_Reader.$key_cue_registry.{$key}" exact="$cue" />
        <debug_text text="'Cue %s registered to key %s.'.[$cue.name, $key]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
      </do_else>
      
      <!-- Update the server. If it isn't connected, ignore any error. -->
      <include_actions ref="Register_Keys_With_Server"/>
      
      <!-- Make sure the read loop is started, if it wasn't already. -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
      
    </actions>    
  </cue>
  
    
  <!--
    User function to unregister a key/cue. 
    Params are the same as for Register_Key.
    If this was the only cue registered (across all keys), the key listerner
    loop will stop itself.
    
    TODO: test this.
    
    Usage example:
      <signal_cue_instantly 
        cue="md.Key_Capture.Unregister_Key" 
        param="table[$key='w', $cue=OnKeyPress]">
  -->
  <cue name="Unregister_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <set_value name="$key" exact="event.param.{'$key'}"/>
      <set_value name="$cue" exact="event.param.{'$cue'}"/>
      
      <!-- Make sure there is a table entry for the key. -->
      <do_if value="not Server_Reader.$key_cue_registry.{$key}?">
        <!-- Print some warning. -->
        <debug_text text="'Warning, key %s has no registered cues.'.[$key]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
      </do_if>
      
      <!-- Check if the cue is recorded for this key. -->
      <set_value name="$cue_index" exact="Server_Reader.$key_cue_registry.{$key}.indexof.{$cue}"/>
      <do_if value="$cue_index == 0">
        <!-- It isn't recorded, so print a warning. -->
        <debug_text text="'Warning, cue %s is not registered to key %s.'.[$cue.name, $key]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
      </do_if>
      
      <do_else>
        <!-- Proceed with removal. -->
        <remove_value name="Server_Reader.$key_cue_registry.{$key}.{$cue_index}" />
        <debug_text text="'Removed cue %s from key %s.'.[$cue.name, $key]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
        
        <!-- If the key's cue list is empty, also remove the key itself. -->
        <do_if value="Server_Reader.$key_cue_registry.{$key}.count == 0">
          <remove_value name="Server_Reader.$key_cue_registry.{$key}" />
          <debug_text text="'No remaining listeners to key %s; removing it.'.[$key]" 
                      chance="Server_Reader.$DebugChance" filter="general"/>
          
          <!-- Update the server. If it isn't connected, ignore any error. -->
          <include_actions ref="Register_Keys_With_Server"/>
        </do_if>
      </do_else>      
      
    </actions>    
  </cue>      
      
    
  <!-- Lib function to update the server list of registered keys. -->
  <library name="Register_Keys_With_Server">
    <actions>
      <!-- Suppress if not connected to server, to reduce log confusion. -->
      <do_if value="Server_Reader.$server_connected == 1">
      
        <!--Start by merging the keys together, semicolon separated. -->
        <set_value name="$joined_keys" exact="''" />
        <do_all exact="Server_Reader.$key_cue_registry.keys.count" counter="$i">
          <set_value name="$joined_keys" 
            exact="$joined_keys + Server_Reader.$key_cue_registry.keys.list.{$i} + ';'"/>
        </do_all>
        
        <!-- Send this to the server. -->
        <signal_cue_instantly 
          cue="md.Named_Pipes.Write" 
          param="table[$pipe = Server_Reader.$Pipe_Name, $msg = 'setkeys:'+$joined_keys ]"/>
        
      </do_if>
    </actions>
  </library>
    
</cues>

</mdscript>